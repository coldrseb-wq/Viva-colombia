#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <stdint.h>
#include "../include/lexer.h"
#include "../include/parser.h"
#include "../include/interpreter.h"
#include "../include/compiler.h"  // Include compiler.h first
#include "../include/machine_code.h"  // Then machine_code.h


#define MAX_VARIABLES 100

#define MAX_STRINGS 100


// Variable and string info structures
typedef struct {
    char name[64];
    int is_string;  // 1 for string, 0 for number
} VariableInfo;

typedef struct {
    char value[256];
    char label[64];
} StringInfo;

#define MAX_FILENAME_LENGTH 256
#define MAX_CODE_BUFFER 8192

typedef enum {
    OUTPUT_C,
    OUTPUT_ASM,
    OUTPUT_ELF
} OutputMode;

// External symbol information
typedef struct {
    char name[64];
    int symbol_index;  // Index in the symbol table
} ExternalSymbol;

#define MAX_EXTERNAL_SYMBOLS 100

typedef struct {
    FILE* output_file;
    OutputMode output_mode;
    PlatformTarget platform_target;  // Target platform for cross-compilation
    int indentation_level;
    VariableInfo variables[MAX_VARIABLES];
    int var_count;
    StringInfo strings[MAX_STRINGS];
    int string_count;
    char code_buffer[MAX_CODE_BUFFER];  // Buffer to store code section temporarily (for ASM mode)
    int code_buffer_pos;
    char output_filename[MAX_FILENAME_LENGTH];  // Store the original output filename
    MachineCode* machine_code;  // Machine code for machine code generation modes
    // For machine code generation: track external symbols and relocations
    ExternalSymbol external_symbols[MAX_EXTERNAL_SYMBOLS];
    int external_symbol_count;
    ELFFile* elf_file;  // Reference to ELF file structure for ELF target
    // Add platform-specific structures as needed
    void* platform_specific_data;  // For Mach-O, PE/COFF specific data
} Compiler;


Compiler* init_compiler(const char* output_filename, OutputMode mode);
void free_compiler(Compiler* compiler);
void write_indentation(Compiler* compiler);
void compile_ast_to_c(Compiler* compiler, ASTNode* node, TokenStream* tokens);
void compile_ast_to_c_internal(Compiler* compiler, ASTNode* node, int inside_function);
void compile_expression(Compiler* compiler, ASTNode* node);
void compile_program_node(Compiler* compiler, ASTNode* node);
void compile_function_call_node(Compiler* compiler, ASTNode* node);
void compile_identifier_node(Compiler* compiler, ASTNode* node);
void compile_number_node(Compiler* compiler, ASTNode* node);
void compile_var_decl_node(Compiler* compiler, ASTNode* node, int is_spanish);

Compiler* init_compiler(const char* output_filename, OutputMode mode) {
    Compiler* compiler = malloc(sizeof(Compiler));
    compiler->output_mode = mode;
    compiler->platform_target = PLATFORM_LINUX; // Default to Linux for backward compatibility

    if (mode == OUTPUT_ELF) {
        // For ELF output, initialize machine code generator
        compiler->output_file = fopen(output_filename, "w"); // Will be handled in free_compiler
        compiler->machine_code = init_machine_code();
        compiler->elf_file = init_elf_file(); // Initialize ELF file structure
    } else {
        compiler->output_file = fopen(output_filename, "w");
        compiler->machine_code = NULL;
        compiler->elf_file = NULL;
    }

    compiler->indentation_level = 0;
    compiler->var_count = 0;
    compiler->string_count = 0;
    compiler->code_buffer_pos = 0;
    compiler->external_symbol_count = 0;
    compiler->platform_specific_data = NULL;
    strncpy(compiler->output_filename, output_filename, MAX_FILENAME_LENGTH - 1);
    compiler->output_filename[MAX_FILENAME_LENGTH - 1] = '\0';

    if (compiler->output_file != NULL) {
        if (mode == OUTPUT_C) {
            // Write standard C headers and runtime declarations
            fprintf(compiler->output_file, "// Generated by Viva compiler\n");
            fprintf(compiler->output_file, "#include <stdio.h>\n");
            fprintf(compiler->output_file, "#include <stdlib.h>\n");
            fprintf(compiler->output_file, "#include <string.h>\n\n");

            // Write builtin function declarations
            fprintf(compiler->output_file, "// Builtin functions\n");
            fprintf(compiler->output_file, "int builtin_print(char* str) { printf(\"%%s\", str); return 0; }\n");
            fprintf(compiler->output_file, "int builtin_println(char* str) { printf(\"%%s\\n\", str); return 0; }\n");
            fprintf(compiler->output_file, "void builtin_print_num(int num) { printf(\"%%d\", num); }\n");
            fprintf(compiler->output_file, "void builtin_println_num(int num) { printf(\"%%d\\n\", num); }\n");
            fprintf(compiler->output_file, "void builtin_simon_bolivar() { printf(\"Simón Bolívar: Libertador de Colombia, Venezuela, Ecuador, Perú y Bolivia\\n\"); }\n");
            fprintf(compiler->output_file, "void builtin_francisco_narino() { printf(\"Francisco de Paula Santander y Nariño: Héroe de la independencia colombiana\\n\"); }\n");
            fprintf(compiler->output_file, "void builtin_maria_cano() { printf(\"María Cano: Líder obrera y feminista colombiana\\n\"); }\n");
            fprintf(compiler->output_file, "void builtin_jorge_eliecer_gaitan() { printf(\"Jorge Eliécer Gaitán: Líder político y defensor del pueblo colombiano\\n\"); }\n");
            fprintf(compiler->output_file, "void builtin_gabriel_garcia_marquez() { printf(\"Gabriel García Márquez: Nobel de Literatura, autor de Cien Años de Soledad\\n\"); }\n");
        } else if (mode == OUTPUT_ASM) {
            // Write x86-64 assembly header
            fprintf(compiler->output_file, "; Generated by Viva Colombia compiler\n");
            fprintf(compiler->output_file, "section .data\n");
            fprintf(compiler->output_file, "    fmt_print db \"%%s\", 10, 0\n");
            fprintf(compiler->output_file, "    fmt_print_num db \"%%d\", 10, 0\n");
            fprintf(compiler->output_file, "    str_simon db \"Simón Bolívar: Libertador de Colombia, Venezuela, Ecuador, Perú y Bolivia\", 10, 0\n");
            fprintf(compiler->output_file, "    str_francisco db \"Francisco de Paula Santander y Nariño: Héroe de la independencia colombiana\", 10, 0\n");
            fprintf(compiler->output_file, "    str_maria db \"María Cano: Líder obrera y feminista colombiana\", 10, 0\n");
            fprintf(compiler->output_file, "    str_jorge db \"Jorge Eliécer Gaitán: Líder político y defensor del pueblo colombiano\", 10, 0\n");
            fprintf(compiler->output_file, "    str_gabriel db \"Gabriel García Márquez: Nobel de Literatura, autor de Cien Años de Soledad\", 10, 0\n\n");
            fprintf(compiler->output_file, "section .text\n");
            fprintf(compiler->output_file, "    global main\n");
            fprintf(compiler->output_file, "    extern printf\n\n");
        }

        return compiler;
    }

    free(compiler);
    return NULL;
}

void finish_compiler(Compiler* compiler) {
    if (compiler != NULL && compiler->output_file != NULL) {
        fclose(compiler->output_file);
        compiler->output_file = NULL;
    }
}

void add_variable(Compiler* compiler, const char* name, int is_string) {
    if (compiler->var_count < MAX_VARIABLES) {
        strncpy(compiler->variables[compiler->var_count].name, name, sizeof(compiler->variables[0].name) - 1);
        compiler->variables[compiler->var_count].name[sizeof(compiler->variables[0].name) - 1] = '\0';
        compiler->variables[compiler->var_count].is_string = is_string;
        compiler->var_count++;
    }
}

int is_variable_string(Compiler* compiler, const char* name) {
    for (int i = 0; i < compiler->var_count; i++) {
        if (strcmp(compiler->variables[i].name, name) == 0) {
            return compiler->variables[i].is_string;
        }
    }
    // Default to number if not found
    return 0;
}

// Function to create a unique label for a string literal
char* create_string_label(Compiler* compiler, const char* string_literal) {
    // Remove quotes from the string literal first
    char clean_string[256];
    if (string_literal[0] == '"' && string_literal[strlen(string_literal)-1] == '"') {
        strncpy(clean_string, string_literal + 1, strlen(string_literal) - 2);
        clean_string[strlen(string_literal) - 2] = '\0';
    } else {
        strcpy(clean_string, string_literal);
    }

    // Check if string already exists
    for (int i = 0; i < compiler->string_count; i++) {
        if (strcmp(compiler->strings[i].value, clean_string) == 0) {
            return compiler->strings[i].label;
        }
    }

    // Create new string entry if there's space
    if (compiler->string_count < MAX_STRINGS) {
        strcpy(compiler->strings[compiler->string_count].value, clean_string);
        sprintf(compiler->strings[compiler->string_count].label, "str_literal_%d", compiler->string_count);

        compiler->string_count++;
        return compiler->strings[compiler->string_count - 1].label;
    }

    return NULL; // Error case
}

void output_collected_strings(Compiler* compiler) {
    if (compiler->output_mode == OUTPUT_ASM) {
        // Output all collected string literals to the data section
        for (int i = 0; i < compiler->string_count; i++) {
            fprintf(compiler->output_file, "    %s: db \"%s\", 0\n",
                    compiler->strings[i].label, compiler->strings[i].value);
        }
    }
}

void append_to_buffer(Compiler* compiler, const char* format, ...) {
    if (compiler->output_mode == OUTPUT_ASM) {
        va_list args;
        va_start(args, format);
        int remaining = MAX_CODE_BUFFER - compiler->code_buffer_pos;
        if (remaining > 0) {
            int written = vsnprintf(compiler->code_buffer + compiler->code_buffer_pos, remaining, format, args);
            if (written > 0) {
                compiler->code_buffer_pos += written;
            }
        }
        va_end(args);
    } else {
        // For C output, write directly to file as before
        va_list args;
        va_start(args, format);
        vfprintf(compiler->output_file, format, args);
        va_end(args);
    }
}

void write_indentation(Compiler* compiler) {
    if (compiler->output_mode == OUTPUT_ASM) {
        int remaining = MAX_CODE_BUFFER - compiler->code_buffer_pos;
        if (remaining >= 4) {
            strcpy(compiler->code_buffer + compiler->code_buffer_pos, "    ");
            compiler->code_buffer_pos += 4;
        }
    } else {
        for (int i = 0; i < compiler->indentation_level; i++) {
            fprintf(compiler->output_file, "    ");
        }
    }
}

void compile_program_node(Compiler* compiler, ASTNode* node) {
    if (compiler->output_mode == OUTPUT_C) {
        fprintf(compiler->output_file, "\n// Program start\n");
        fprintf(compiler->output_file, "int main() {\n");
        compiler->indentation_level++;

        // Process the first statement
        if (node->left != NULL) {
            compile_ast_to_c_internal(compiler, node->left, 1);  // 1 for inside main function
        }

        // Process remaining statements by following the right pointers of the first statement
        ASTNode* current = NULL;
        if (node->left != NULL) {
            current = node->left->right;
        }
        while (current != NULL) {
            compile_ast_to_c_internal(compiler, current, 1);  // 1 for inside main function
            current = current->right;
        }

        fprintf(compiler->output_file, "    return 0;\n");
        compiler->indentation_level--;
        fprintf(compiler->output_file, "}\n");
    } else if (compiler->output_mode == OUTPUT_ASM) {
        append_to_buffer(compiler, "main:\n");
        append_to_buffer(compiler, "    push rbp\n");
        append_to_buffer(compiler, "    mov rbp, rsp\n");

        // Process the first statement
        if (node->left != NULL) {
            compile_ast_to_c_internal(compiler, node->left, 1);  // 1 for inside main function
        }

        // Process remaining statements by following the right pointers of the first statement
        ASTNode* current = NULL;
        if (node->left != NULL) {
            current = node->left->right;
        }
        while (current != NULL) {
            compile_ast_to_c_internal(compiler, current, 1);  // 1 for inside main function
            current = current->right;
        }

        append_to_buffer(compiler, "    mov rax, 0      ; return 0\n");
        append_to_buffer(compiler, "    pop rbp\n");
        append_to_buffer(compiler, "    ret\n");
    } else if (compiler->output_mode == OUTPUT_ELF) {
        // For ELF mode, generate the main function in machine code
        if (compiler->machine_code) {
            encode_push_rbp(compiler->machine_code);
            encode_mov_rbp_rsp(compiler->machine_code);

            // Process the first statement
            if (node->left != NULL) {
                compile_ast_to_c_internal(compiler, node->left, 1);  // 1 for inside main function
            }

            // Process remaining statements by following the right pointers of the first statement
            ASTNode* current = NULL;
            if (node->left != NULL) {
                current = node->left->right;
            }
            while (current != NULL) {
                compile_ast_to_c_internal(compiler, current, 1);  // 1 for inside main function
                current = current->right;
            }

            encode_mov_rax_imm32(compiler->machine_code, 0);  // return 0
            encode_pop_rbp(compiler->machine_code);
            encode_ret(compiler->machine_code);
        }
    }
}

void compile_function_call_node(Compiler* compiler, ASTNode* node) {
    if (compiler->output_mode == OUTPUT_C) {
        write_indentation(compiler);

        if (strcmp(node->value, "println") == 0) {
            if (node->left != NULL) {
                if (node->left->type == IDENTIFIER_NODE) {
                    // Need to handle both string literals and variable names
                    char* value = node->left->value;
                    if (value[0] == '"' && value[strlen(value)-1] == '"') {
                        // It's a string literal - use string function
                        fprintf(compiler->output_file, "builtin_println(%s);\n", value);
                    } else {
                        // It's a variable name - check the stored type information
                        int is_string_var = is_variable_string(compiler, value);

                        if (is_string_var) {
                            fprintf(compiler->output_file, "builtin_println(%s);\n", value);
                        } else {
                            fprintf(compiler->output_file, "builtin_println_num(%s);\n", value);
                        }
                    }
                } else if (node->left->type == NUMBER_NODE) {
                    // For numbers, use the number-specific function
                    fprintf(compiler->output_file, "builtin_println_num(%s);\n", node->left->value);
                }
            } else {
                // No argument - print empty line
                fprintf(compiler->output_file, "builtin_println(\"\");\n");
            }
        }
        else if (strcmp(node->value, "print") == 0) {
            if (node->left != NULL) {
                if (node->left->type == IDENTIFIER_NODE) {
                    char* value = node->left->value;
                    if (value[0] == '"' && value[strlen(value)-1] == '"') {
                        // It's a string literal
                        fprintf(compiler->output_file, "builtin_print(%s);\n", value);
                    } else {
                        // It's a variable name - check the stored type information
                        int is_string_var = is_variable_string(compiler, value);

                        if (is_string_var) {
                            fprintf(compiler->output_file, "builtin_print(%s);\n", value);
                        } else {
                            fprintf(compiler->output_file, "builtin_print_num(%s);\n", value);
                        }
                    }
                } else if (node->left->type == NUMBER_NODE) {
                    // For numbers, use the number-specific function
                    fprintf(compiler->output_file, "builtin_print_num(%s);\n", node->left->value);
                }
            }
        }
        else if (strcmp(node->value, "simon_bolivar") == 0) {
            fprintf(compiler->output_file, "builtin_simon_bolivar();\n");
        }
        else if (strcmp(node->value, "francisco_narino") == 0) {
            fprintf(compiler->output_file, "builtin_francisco_narino();\n");
        }
        else if (strcmp(node->value, "maria_cano") == 0) {
            fprintf(compiler->output_file, "builtin_maria_cano();\n");
        }
        else if (strcmp(node->value, "jorge_eliecer_gaitan") == 0) {
            fprintf(compiler->output_file, "builtin_jorge_eliecer_gaitan();\n");
        }
        else if (strcmp(node->value, "gabriel_garcia_marquez") == 0) {
            fprintf(compiler->output_file, "builtin_gabriel_garcia_marquez();\n");
        }
        else {
            fprintf(compiler->output_file, "// Unknown function: %s\n", node->value);
        }
    } else if (compiler->output_mode == OUTPUT_ASM) {
        // Assembly implementation for println function
        if (strcmp(node->value, "println") == 0) {
            if (node->left != NULL) {
                if (node->left->type == IDENTIFIER_NODE) {
                    char* value = node->left->value;
                    if (value[0] == '"' && value[strlen(value)-1] == '"') {
                        // String literal - create or get label and print it
                        char* label = create_string_label(compiler, value);
                        append_to_buffer(compiler, "    ; Print string literal: %s\n", value);
                        append_to_buffer(compiler, "    mov rdi, fmt_print\n");  // format string
                        append_to_buffer(compiler, "    mov rsi, %s\n", label);  // string label
                        append_to_buffer(compiler, "    xor rax, rax\n");  // no vector registers used
                        append_to_buffer(compiler, "    call printf\n");
                    } else {
                        // Variable - check the stored type information
                        int is_string_var = is_variable_string(compiler, value);
                        if (is_string_var) {
                            append_to_buffer(compiler, "    ; Print string variable: %s\n", value);
                            append_to_buffer(compiler, "    mov rdi, fmt_print\n");  // format string
                            append_to_buffer(compiler, "    mov rsi, %s\n", value);  // variable
                            append_to_buffer(compiler, "    xor rax, rax\n");  // no vector registers used
                            append_to_buffer(compiler, "    call printf\n");
                        } else {
                            append_to_buffer(compiler, "    ; Print number variable: %s\n", value);
                            append_to_buffer(compiler, "    mov rdi, fmt_print_num\n");  // format string
                            append_to_buffer(compiler, "    mov rsi, %s\n", value);  // number variable
                            append_to_buffer(compiler, "    xor rax, rax\n");  // no vector registers used
                            append_to_buffer(compiler, "    call printf\n");
                        }
                    }
                } else if (node->left->type == NUMBER_NODE) {
                    // Direct number
                    append_to_buffer(compiler, "    ; Print number literal: %s\n", node->left->value);
                    append_to_buffer(compiler, "    mov rdi, fmt_print_num\n");  // format string
                    append_to_buffer(compiler, "    mov rsi, %s\n", node->left->value);  // number literal
                    append_to_buffer(compiler, "    xor rax, rax\n");  // no vector registers used
                    append_to_buffer(compiler, "    call printf\n");
                }
            } else {
                // No argument - print empty line
                append_to_buffer(compiler, "    ; Print empty line\n");
                append_to_buffer(compiler, "    mov rdi, fmt_print\n");  // format string
                append_to_buffer(compiler, "    mov rsi, 0\n");  // empty string
                append_to_buffer(compiler, "    xor rax, rax\n");  // no vector registers used
                append_to_buffer(compiler, "    call printf\n");
            }
        }
        else if (strcmp(node->value, "simon_bolivar") == 0) {
            append_to_buffer(compiler, "    ; Print Simon Bolivar message\n");
            append_to_buffer(compiler, "    mov rdi, fmt_print\n");  // format string
            append_to_buffer(compiler, "    mov rsi, str_simon\n");  // message
            append_to_buffer(compiler, "    xor rax, rax\n");  // no vector registers used
            append_to_buffer(compiler, "    call printf\n");
        }
        else if (strcmp(node->value, "francisco_narino") == 0) {
            append_to_buffer(compiler, "    ; Print Francisco Nariño message\n");
            append_to_buffer(compiler, "    mov rdi, fmt_print\n");  // format string
            append_to_buffer(compiler, "    mov rsi, str_francisco\n");  // message
            append_to_buffer(compiler, "    xor rax, rax\n");  // no vector registers used
            append_to_buffer(compiler, "    call printf\n");
        }
        else if (strcmp(node->value, "maria_cano") == 0) {
            append_to_buffer(compiler, "    ; Print Maria Cano message\n");
            append_to_buffer(compiler, "    mov rdi, fmt_print\n");  // format string
            append_to_buffer(compiler, "    mov rsi, str_maria\n");  // message
            append_to_buffer(compiler, "    xor rax, rax\n");  // no vector registers used
            append_to_buffer(compiler, "    call printf\n");
        }
        else if (strcmp(node->value, "jorge_eliecer_gaitan") == 0) {
            append_to_buffer(compiler, "    ; Print Jorge Gaitán message\n");
            append_to_buffer(compiler, "    mov rdi, fmt_print\n");  // format string
            append_to_buffer(compiler, "    mov rsi, str_jorge\n");  // message
            append_to_buffer(compiler, "    xor rax, rax\n");  // no vector registers used
            append_to_buffer(compiler, "    call printf\n");
        }
        else if (strcmp(node->value, "gabriel_garcia_marquez") == 0) {
            append_to_buffer(compiler, "    ; Print Gabriel García Márquez message\n");
            append_to_buffer(compiler, "    mov rdi, fmt_print\n");  // format string
            append_to_buffer(compiler, "    mov rsi, str_gabriel\n");  // message
            append_to_buffer(compiler, "    xor rax, rax\n");  // no vector registers used
            append_to_buffer(compiler, "    call printf\n");
        }
        else {
            append_to_buffer(compiler, "    ; Unknown function: %s\n", node->value);
        }
    } else if (compiler->output_mode == OUTPUT_ELF) {
        // For ELF mode, we need to generate actual machine code for function calls
        if (strcmp(node->value, "println") == 0) {
            if (node->left != NULL) {
                if (node->left->type == IDENTIFIER_NODE) {
                    char* value = node->left->value;
                    if (value[0] == '"' && value[strlen(value)-1] == '"') {
                        // String literal - generate code to load string address into rdi
                        // and call printf
                        char* label = create_string_label(compiler, value);

                        // Load format string address into RDI (first argument)
                        encode_mov_rbp_rdi(compiler->machine_code);  // Placeholder for moving string to RDI
                        // In real implementation, we would need to handle string addresses properly

                        // Call printf (which needs relocation info)
                        encode_call_external(compiler->machine_code);
                        // In a complete implementation, we would add relocation info here
                        if (compiler->machine_code) {
                            add_relocation_entry(compiler->machine_code, 0, R_X86_64_PC32, -4);  // Placeholder
                        }
                    }
                } else if (node->left->type == NUMBER_NODE) {
                    // Number printing would need different handling
                    // For now, just placeholder
                    encode_call_external(compiler->machine_code);
                    if (compiler->machine_code) {
                        add_relocation_entry(compiler->machine_code, 0, R_X86_64_PC32, -4);  // Placeholder
                    }
                }
            } else {
                // No argument - print empty line
                encode_call_external(compiler->machine_code);
                if (compiler->machine_code) {
                    add_relocation_entry(compiler->machine_code, 0, R_X86_64_PC32, -4);  // Placeholder
                }
            }
        }
        // Add other function handlers as needed for ELF mode
        else if (strcmp(node->value, "simon_bolivar") == 0) {
            encode_call_external(compiler->machine_code);
            if (compiler->machine_code) {
                add_relocation_entry(compiler->machine_code, 0, R_X86_64_PC32, -4);  // Placeholder
            }
        }
        else if (strcmp(node->value, "francisco_narino") == 0) {
            encode_call_external(compiler->machine_code);
            if (compiler->machine_code) {
                add_relocation_entry(compiler->machine_code, 0, R_X86_64_PC32, -4);  // Placeholder
            }
        }
        else if (strcmp(node->value, "maria_cano") == 0) {
            encode_call_external(compiler->machine_code);
            if (compiler->machine_code) {
                add_relocation_entry(compiler->machine_code, 0, R_X86_64_PC32, -4);  // Placeholder
            }
        }
        else if (strcmp(node->value, "jorge_eliecer_gaitan") == 0) {
            encode_call_external(compiler->machine_code);
            if (compiler->machine_code) {
                add_relocation_entry(compiler->machine_code, 0, R_X86_64_PC32, -4);  // Placeholder
            }
        }
        else if (strcmp(node->value, "gabriel_garcia_marquez") == 0) {
            encode_call_external(compiler->machine_code);
            if (compiler->machine_code) {
                add_relocation_entry(compiler->machine_code, 0, R_X86_64_PC32, -4);  // Placeholder
            }
        }
        else {
            // Unknown function
            append_to_buffer(compiler, "; Unknown function: %s\n", node->value);
        }
    }
}

void compile_function_decl_node(Compiler* compiler, ASTNode* node) {
    if (compiler->output_mode == OUTPUT_C) {
        write_indentation(compiler);
        // For now, generate a C-style function declaration
        // The function name is in node->value, parameters and body would be in node->left and node->right
        fprintf(compiler->output_file, "// Function declaration: %s\n", node->value);

        if (node->left != NULL) {
            // This would be the function parameters (in a full implementation)
            fprintf(compiler->output_file, "int %s() { // Parameters would go here\n", node->value);
            compiler->indentation_level++;

            // Compile the function body (would be in node->right in a full implementation)
            if (node->right != NULL) {
                // Process function body statements
                ASTNode* current = node->right;
                while (current != NULL) {
                    compile_ast_to_c_internal(compiler, current, 1); // 1 for inside function
                    if (current->right != NULL && current->right != node->right) { // avoid infinite loop
                        current = current->right;
                    } else {
                        break;
                    }
                }
            }

            compiler->indentation_level--;
            fprintf(compiler->output_file, "    return 0; // Placeholder\n}\n");
        }
    } else if (compiler->output_mode == OUTPUT_ASM) {
        append_to_buffer(compiler, "; Function declaration: %s\n", node->value);
        // For assembly, would generate function label and prologue/epilogue
        append_to_buffer(compiler, "%s:\n", node->value);
        append_to_buffer(compiler, "    push rbp\n");
        append_to_buffer(compiler, "    mov rbp, rsp\n");

        // Compile the function body if available
        if (node->right != NULL) {
            // Process function body statements
            ASTNode* current = node->right;
            while (current != NULL) {
                compile_ast_to_c_internal(compiler, current, 1); // 1 for inside function
                if (current->right != NULL && current->right != node->right) { // avoid infinite loop
                    current = current->right;
                } else {
                    break;
                }
            }
        }

        append_to_buffer(compiler, "    pop rbp\n");
        append_to_buffer(compiler, "    ret\n");
    } else if (compiler->output_mode == OUTPUT_ELF) {
        // For ELF mode, generate the function in machine code
        if (compiler->machine_code) {
            // Add function symbol to the symbol table
            if (compiler->elf_file) {
                // Create the function in the text section
                // Start with function prologue
                encode_push_rbp(compiler->machine_code);
                encode_mov_rbp_rsp(compiler->machine_code);

                // Compile the function body if available
                if (node->right != NULL) {
                    // Process function body statements
                    ASTNode* current = node->right;
                    while (current != NULL) {
                        compile_ast_to_c_internal(compiler, current, 1); // 1 for inside function
                        if (current->right != NULL && current->right != node->right) { // avoid infinite loop
                            current = current->right;
                        } else {
                            break;
                        }
                    }
                }

                // Function epilogue - for now just return 0
                encode_mov_rax_imm32(compiler->machine_code, 0);  // Return 0
                encode_pop_rbp(compiler->machine_code);
                encode_ret(compiler->machine_code);

                // In a complete implementation, we would add function symbol to symbol table
                // add_symbol_to_table(compiler->elf_file, node->value,
                //                    compiler->machine_code->size - 15, // Approximate address - return instruction size
                //                    0,  // Size (0 for now)
                //                    ELF64_ST_INFO(STB_GLOBAL, STT_FUNC),
                //                    compiler->elf_file->text_section_idx + 1);  // +1 for null section
            }
        }
    }
}

void compile_identifier_node(Compiler* compiler, ASTNode* node) {
    if (compiler->output_mode == OUTPUT_C) {
        write_indentation(compiler);
        fprintf(compiler->output_file, "// Identifier: %s\n", node->value);
    } else if (compiler->output_mode == OUTPUT_ASM) {
        // In assembly mode, identifier nodes could be variable references
        append_to_buffer(compiler, "; Identifier: %s\n", node->value);
    }
}

void compile_number_node(Compiler* compiler, ASTNode* node) {
    if (compiler->output_mode == OUTPUT_C) {
        write_indentation(compiler);
        fprintf(compiler->output_file, "// Number: %s\n", node->value);
    } else if (compiler->output_mode == OUTPUT_ASM) {
        append_to_buffer(compiler, "; Number: %s\n", node->value);
    }
}

// Function to compile an expression directly to the output file
void compile_expression(Compiler* compiler, ASTNode* node) {
    if (node == NULL) return;

    switch (node->type) {
        case NUMBER_NODE:
            if (compiler->output_mode == OUTPUT_C) {
                fprintf(compiler->output_file, "%s", node->value);
            } else if (compiler->output_mode == OUTPUT_ASM) {
                // In assembly context, just return the number value
                // This is more complex for actual expression evaluation in assembly
                // For now we'll add it to buffer
                append_to_buffer(compiler, "%s", node->value);
            } else if (compiler->output_mode == OUTPUT_ELF) {
                // For ELF mode, we need to move the immediate value to RAX
                if (compiler->machine_code) {
                    int32_t value = atoi(node->value);
                    encode_mov_rax_imm32(compiler->machine_code, value);
                }
            }
            break;

        case IDENTIFIER_NODE:
            // For identifiers, check if they are string literals (have quotes)
            if (node->value[0] == '"' && node->value[strlen(node->value)-1] == '"') {
                if (compiler->output_mode == OUTPUT_C) {
                    fprintf(compiler->output_file, "%s", node->value);  // String literal
                } else if (compiler->output_mode == OUTPUT_ASM) {
                    char* label = create_string_label(compiler, node->value);
                    append_to_buffer(compiler, "%s", label);  // Use the label
                } else if (compiler->output_mode == OUTPUT_ELF) {
                    // For string literals in ELF mode, we would need to load their address
                    // This would require complex string handling - for now, just a placeholder
                    append_to_buffer(compiler, "; String literal expression not fully implemented\n");
                }
            } else {
                if (compiler->output_mode == OUTPUT_C) {
                    fprintf(compiler->output_file, "%s", node->value);  // Variable name
                } else if (compiler->output_mode == OUTPUT_ASM) {
                    append_to_buffer(compiler, "%s", node->value);  // Variable name
                } else if (compiler->output_mode == OUTPUT_ELF) {
                    // For variable lookup in ELF mode, we need to load from memory
                    // We need to find where the variable is stored and load it to RAX
                    // For now, we'll assume it's stored at some offset from RBP
                    // This would require variable tracking in the compiler structure
                    int var_offset = -8; // Placeholder - in real implementation would track actual variable locations
                    if (compiler->machine_code) {
                        encode_mov_rax_from_memory(compiler->machine_code, var_offset);
                    }
                }
            }
            break;

        case BINARY_OP_NODE:
            // Handle binary operations like +, -, *, /
            if (compiler->output_mode == OUTPUT_C) {
                fprintf(compiler->output_file, "(");
                compile_expression(compiler, node->left);
                fprintf(compiler->output_file, " %s ", node->value ? node->value : "");
                compile_expression(compiler, node->right);
                fprintf(compiler->output_file, ")");
            } else if (compiler->output_mode == OUTPUT_ASM) {
                // For assembly, generate actual calculation code
                // Load left operand to EAX
                if (node->left && node->left->type == NUMBER_NODE) {
                    append_to_buffer(compiler, "    mov eax, %s  ; Load left operand\n", node->left->value);
                } else if (node->left && node->left->type == IDENTIFIER_NODE) {
                    // For now, assuming variables are stored at [rbp-8], [rbp-16], etc.
                    append_to_buffer(compiler, "    mov eax, DWORD PTR [rbp-8]  ; Load left operand: %s\n", node->left->value);
                }

                // Load right operand to EBX
                if (node->right && node->right->type == NUMBER_NODE) {
                    append_to_buffer(compiler, "    mov ebx, %s  ; Load right operand\n", node->right->value);
                } else if (node->right && node->right->type == IDENTIFIER_NODE) {
                    append_to_buffer(compiler, "    mov ebx, DWORD PTR [rbp-16]  ; Load right operand: %s\n", node->right->value);
                }

                // Perform the operation
                if (node->value && strcmp(node->value, "+") == 0) {
                    append_to_buffer(compiler, "    add eax, ebx  ; Perform addition\n");
                } else if (node->value && strcmp(node->value, "-") == 0) {
                    append_to_buffer(compiler, "    sub eax, ebx  ; Perform subtraction\n");
                } else if (node->value && strcmp(node->value, "*") == 0) {
                    append_to_buffer(compiler, "    imul eax, ebx  ; Perform multiplication\n");
                } else if (node->value && strcmp(node->value, "/") == 0) {
                    append_to_buffer(compiler, "    cdq            ; Sign-extend EAX into EDX\n");
                    append_to_buffer(compiler, "    idiv ebx       ; Perform division\n");
                } else if (node->value && strcmp(node->value, ">") == 0) {
                    append_to_buffer(compiler, "    cmp eax, ebx   ; Compare left > right\n");
                    append_to_buffer(compiler, "    setg al        ; Set AL to 1 if greater, 0 otherwise\n");
                    append_to_buffer(compiler, "    movzx eax, al  ; Zero-extend AL to EAX\n");
                } else if (node->value && strcmp(node->value, "<") == 0) {
                    append_to_buffer(compiler, "    cmp eax, ebx   ; Compare left < right\n");
                    append_to_buffer(compiler, "    setl al        ; Set AL to 1 if less, 0 otherwise\n");
                    append_to_buffer(compiler, "    movzx eax, al  ; Zero-extend AL to EAX\n");
                } else if (node->value && strcmp(node->value, ">=") == 0) {
                    append_to_buffer(compiler, "    cmp eax, ebx   ; Compare left >= right\n");
                    append_to_buffer(compiler, "    setge al       ; Set AL to 1 if greater or equal, 0 otherwise\n");
                    append_to_buffer(compiler, "    movzx eax, al  ; Zero-extend AL to EAX\n");
                } else if (node->value && strcmp(node->value, "<=") == 0) {
                    append_to_buffer(compiler, "    cmp eax, ebx   ; Compare left <= right\n");
                    append_to_buffer(compiler, "    setle al       ; Set AL to 1 if less or equal, 0 otherwise\n");
                    append_to_buffer(compiler, "    movzx eax, al  ; Zero-extend AL to EAX\n");
                } else if (node->value && strcmp(node->value, "==") == 0) {
                    append_to_buffer(compiler, "    cmp eax, ebx   ; Compare left == right\n");
                    append_to_buffer(compiler, "    sete al        ; Set AL to 1 if equal, 0 otherwise\n");
                    append_to_buffer(compiler, "    movzx eax, al  ; Zero-extend AL to EAX\n");
                } else if (node->value && strcmp(node->value, "!=") == 0) {
                    append_to_buffer(compiler, "    cmp eax, ebx   ; Compare left != right\n");
                    append_to_buffer(compiler, "    setne al       ; Set AL to 1 if not equal, 0 otherwise\n");
                    append_to_buffer(compiler, "    movzx eax, al  ; Zero-extend AL to EAX\n");
                }
            } else if (compiler->output_mode == OUTPUT_ELF) {
                // For ELF mode, generate machine code for binary operations
                if (compiler->machine_code) {
                    // First, compile the left operand (should put it in RAX)
                    compile_expression(compiler, node->left);
                    // Save RAX to RBX temporarily
                    // In a full implementation, we'd need to handle register allocation properly
                    // For now, assume RAX contains the left operand

                    // Compile the right operand (will put it in RAX)
                    compile_expression(compiler, node->right);
                    // Now RAX has right operand, RBX should have left operand
                    // Actually, we need to be more careful about register management
                    // Let's restructure: evaluate left, save to RBX, then evaluate right to RAX

                    // For now, let's implement a basic version by re-evaluating left operand into RBX
                    // This is not efficient but works for our implementation
                    if (node->left && node->left->type == NUMBER_NODE) {
                        int32_t left_val = atoi(node->left->value);
                        encode_mov_rbx_imm32(compiler->machine_code, left_val);
                    } else if (node->left && node->left->type == IDENTIFIER_NODE) {
                        // Load identifier value to RBX
                        // For now, just use the same placeholder as variable loading
                        int var_offset = -8; // Placeholder
                        encode_mov_rax_from_memory(compiler->machine_code, var_offset);
                        // Move RAX to RBX
                        // We need an instruction to move RAX to RBX
                        uint8_t mov_rbx_rax[] = {0x48, 0x89, 0xC3}; // MOV RBX, RAX
                        append_bytes(compiler->machine_code, mov_rbx_rax, 3);
                    }

                    // Now re-evaluate right operand to RAX
                    if (node->right && node->right->type == NUMBER_NODE) {
                        int32_t right_val = atoi(node->right->value);
                        encode_mov_rax_imm32(compiler->machine_code, right_val);
                    } else if (node->right && node->right->type == IDENTIFIER_NODE) {
                        // Load identifier value to RAX
                        int var_offset = -8; // Placeholder
                        encode_mov_rax_from_memory(compiler->machine_code, var_offset);
                    }

                    // Now perform the operation based on operator
                    if (node->value && strcmp(node->value, "+") == 0) {
                        encode_add_rax_rbx(compiler->machine_code);
                    } else if (node->value && strcmp(node->value, "-") == 0) {
                        encode_sub_rax_rbx(compiler->machine_code);
                    } else if (node->value && strcmp(node->value, "*") == 0) {
                        encode_mul_rbx(compiler->machine_code);
                    } else if (node->value && strcmp(node->value, "/") == 0) {
                        encode_div_rbx(compiler->machine_code);
                    } else if (node->value && strcmp(node->value, ">") == 0) {
                        // For comparison operations in ELF mode: perform comparison and return 1 or 0
                        uint8_t cmp_code[] = {0x48, 0x39, 0xD8}; // CMP RAX, RBX
                        append_bytes(compiler->machine_code, cmp_code, 3);

                        // Set AL to 1 if RAX > RBX (unsigned), otherwise 0
                        uint8_t setg_code[] = {0x0F, 0x9F, 0xC0}; // SETG AL
                        append_bytes(compiler->machine_code, setg_code, 3);

                        // Zero-extend AL to RAX
                        uint8_t movzx_code[] = {0x48, 0x0F, 0xB6, 0xC0}; // MOVZX RAX, AL
                        append_bytes(compiler->machine_code, movzx_code, 4);
                    } else if (node->value && strcmp(node->value, "<") == 0) {
                        // For comparison operations in ELF mode: perform comparison and return 1 or 0
                        uint8_t cmp_code[] = {0x48, 0x39, 0xD8}; // CMP RAX, RBX
                        append_bytes(compiler->machine_code, cmp_code, 3);

                        // Set AL to 1 if RAX < RBX (unsigned), otherwise 0
                        uint8_t setl_code[] = {0x0F, 0x9C, 0xC0}; // SETL AL
                        append_bytes(compiler->machine_code, setl_code, 3);

                        // Zero-extend AL to RAX
                        uint8_t movzx_code[] = {0x48, 0x0F, 0xB6, 0xC0}; // MOVZX RAX, AL
                        append_bytes(compiler->machine_code, movzx_code, 4);
                    } else if (node->value && strcmp(node->value, ">=") == 0) {
                        uint8_t cmp_code[] = {0x48, 0x39, 0xD8}; // CMP RAX, RBX
                        append_bytes(compiler->machine_code, cmp_code, 3);

                        // Set AL to 1 if RAX >= RBX (unsigned), otherwise 0
                        uint8_t setge_code[] = {0x0F, 0x9D, 0xC0}; // SETGE AL
                        append_bytes(compiler->machine_code, setge_code, 3);

                        // Zero-extend AL to RAX
                        uint8_t movzx_code[] = {0x48, 0x0F, 0xB6, 0xC0}; // MOVZX RAX, AL
                        append_bytes(compiler->machine_code, movzx_code, 4);
                    } else if (node->value && strcmp(node->value, "<=") == 0) {
                        uint8_t cmp_code[] = {0x48, 0x39, 0xD8}; // CMP RAX, RBX
                        append_bytes(compiler->machine_code, cmp_code, 3);

                        // Set AL to 1 if RAX <= RBX (unsigned), otherwise 0
                        uint8_t setle_code[] = {0x0F, 0x9E, 0xC0}; // SETLE AL
                        append_bytes(compiler->machine_code, setle_code, 3);

                        // Zero-extend AL to RAX
                        uint8_t movzx_code[] = {0x48, 0x0F, 0xB6, 0xC0}; // MOVZX RAX, AL
                        append_bytes(compiler->machine_code, movzx_code, 4);
                    } else if (node->value && strcmp(node->value, "==") == 0) {
                        uint8_t cmp_code[] = {0x48, 0x39, 0xD8}; // CMP RAX, RBX
                        append_bytes(compiler->machine_code, cmp_code, 3);

                        // Set AL to 1 if RAX == RBX, otherwise 0
                        uint8_t sete_code[] = {0x0F, 0x94, 0xC0}; // SETE AL
                        append_bytes(compiler->machine_code, sete_code, 3);

                        // Zero-extend AL to RAX
                        uint8_t movzx_code[] = {0x48, 0x0F, 0xB6, 0xC0}; // MOVZX RAX, AL
                        append_bytes(compiler->machine_code, movzx_code, 4);
                    } else if (node->value && strcmp(node->value, "!=") == 0) {
                        uint8_t cmp_code[] = {0x48, 0x39, 0xD8}; // CMP RAX, RBX
                        append_bytes(compiler->machine_code, cmp_code, 3);

                        // Set AL to 1 if RAX != RBX, otherwise 0
                        uint8_t setne_code[] = {0x0F, 0x95, 0xC0}; // SETNE AL
                        append_bytes(compiler->machine_code, setne_code, 3);

                        // Zero-extend AL to RAX
                        uint8_t movzx_code[] = {0x48, 0x0F, 0xB6, 0xC0}; // MOVZX RAX, AL
                        append_bytes(compiler->machine_code, movzx_code, 4);
                    } else {
                        // Unknown operator, just keep left operand value
                        append_to_buffer(compiler, "; Unknown binary operator: %s\n", node->value ? node->value : "NULL");
                    }
                }
            }
            break;

        case UNARY_OP_NODE:
            // Handle unary operations like "no" (not)
            if (compiler->output_mode == OUTPUT_C) {
                fprintf(compiler->output_file, "%s ", node->value ? node->value : "");
                compile_expression(compiler, node->right);
            } else if (compiler->output_mode == OUTPUT_ASM) {
                append_to_buffer(compiler, "%s %s", node->value ? node->value : "",
                    node->right ? node->right->value : "unknown");
            } else if (compiler->output_mode == OUTPUT_ELF) {
                // For unary operations in ELF mode
                if (compiler->machine_code) {
                    if (node->value && strcmp(node->value, "no") == 0) {
                        // For "no" (not) operation, perform logical NOT
                        // This is a complex operation that would require proper handling
                        // For now, just compile the operand
                        compile_expression(compiler, node->right);
                        // Apply logical NOT (NOT RAX)
                        uint8_t not_rax[] = {0x48, 0xF7, 0xD0}; // NOT RAX
                        append_bytes(compiler->machine_code, not_rax, 3);
                    } else {
                        // Compile the operand without unary operation
                        compile_expression(compiler, node->right);
                    }
                }
            }
            break;

        default:
            if (compiler->output_mode == OUTPUT_C) {
                fprintf(compiler->output_file, "/* unknown expression */");
            } else if (compiler->output_mode == OUTPUT_ASM) {
                append_to_buffer(compiler, "/* unknown expression */");
            } else if (compiler->output_mode == OUTPUT_ELF) {
                if (compiler->machine_code) {
                    // For unknown expressions in ELF mode, load 0 to RAX
                    encode_mov_rax_imm32(compiler->machine_code, 0);
                }
            }
            break;
    }
}

void compile_var_decl_node(Compiler* compiler, ASTNode* node, int is_spanish) {
    if (compiler->output_mode == OUTPUT_C) {
        write_indentation(compiler);

        int is_string_type = 0;

        if (is_spanish) {
            if (node->left != NULL) {
                if (node->left->type == NUMBER_NODE) {
                    fprintf(compiler->output_file, "int %s = %s; // from decreto\n", node->value, node->left->value);
                    is_string_type = 0;  // Number variable
                } else if (node->left->type == IDENTIFIER_NODE) {
                    // Check if it's a string literal
                    if (node->left->value[0] == '"' && node->left->value[strlen(node->left->value)-1] == '"') {
                        fprintf(compiler->output_file, "char* %s = %s; // from decreto\n", node->value, node->left->value);
                        is_string_type = 1;  // String variable
                    } else {
                        fprintf(compiler->output_file, "char* %s = \"%s\"; // from decreto\n", node->value, node->left->value);
                        is_string_type = 1;  // String variable
                    }
                } else {
                    // For other expression types (like binary operations), handle them properly
                    fprintf(compiler->output_file, "int %s = ", node->value);
                    // Compile the expression as part of the assignment
                    compile_expression(compiler, node->left);
                    fprintf(compiler->output_file, "; // from decreto (expression)\n");
                    is_string_type = 0;  // Assume number for expressions
                }
            }
        } else {
            if (node->left != NULL) {
                if (node->left->type == NUMBER_NODE) {
                    fprintf(compiler->output_file, "int %s = %s; // from let\n", node->value, node->left->value);
                    is_string_type = 0;  // Number variable
                } else if (node->left->type == IDENTIFIER_NODE &&
                           node->left->value[0] == '"' && node->left->value[strlen(node->left->value)-1] == '"') {
                    fprintf(compiler->output_file, "char* %s = %s; // from let\n", node->value, node->left->value);
                    is_string_type = 1;  // String variable
                } else {
                    fprintf(compiler->output_file, "int %s = ", node->value);
                    compile_expression(compiler, node->left);
                    fprintf(compiler->output_file, "; // from let (expression)\n");
                    is_string_type = 0;  // Assume number for expressions
                }
            }
        }

        // Register the variable type for later use
        if (node->value != NULL) {
            add_variable(compiler, node->value, is_string_type);
        }
        fprintf(compiler->output_file, "\n");
    } else if (compiler->output_mode == OUTPUT_ASM) {
        // For assembly, we need to properly handle variable declaration
        if (node->left != NULL) {
            if (node->left->type == NUMBER_NODE) {
                // For number variables - store in local area
                append_to_buffer(compiler, "    ; Declare number variable: %s = %s\n", node->value, node->left->value);
                // Store the immediate value in a memory location
                // Using stack-based allocation: [rbp-8], [rbp-16], etc.
                // For now, we'll store at a fixed location (in a complete implementation,
                // we'd track variable offsets properly)
                int var_offset = -(compiler->var_count * 8); // Allocate 8 bytes per variable
                append_to_buffer(compiler, "    mov DWORD PTR [rbp%d], %s\n",
                                var_offset, node->left->value);
                add_variable(compiler, node->value, 0); // 0 = number
            } else if (node->left->type == IDENTIFIER_NODE) {
                if (node->left->value[0] == '"' && node->left->value[strlen(node->left->value)-1] == '"') {
                    // String literal variable - get or create a label for it
                    char* label = create_string_label(compiler, node->left->value);
                    append_to_buffer(compiler, "    ; Declare string variable: %s = %s\n", node->value, node->left->value);
                    append_to_buffer(compiler, "    mov rax, %s\n", label);  // Move string address to RAX
                    // Store address in variable location
                    int var_offset = -(compiler->var_count * 8);
                    append_to_buffer(compiler, "    mov QWORD PTR [rbp%d], rax\n",
                                    var_offset);
                    add_variable(compiler, node->value, 1); // 1 = string
                } else {
                    // Variable assignment from another variable
                    append_to_buffer(compiler, "    ; Declare variable: %s = %s\n", node->value, node->left->value);
                    // Load value from source variable to RAX, then store to destination
                    // For now just as a placeholder
                    int src_var_offset = -(8); // Placeholder - would need to track actual variable locations
                    int dst_var_offset = -(compiler->var_count * 8);
                    append_to_buffer(compiler, "    mov eax, DWORD PTR [rbp-8]  ; load %s\n", node->left->value);
                    append_to_buffer(compiler, "    mov DWORD PTR [rbp%d], eax\n",
                                    dst_var_offset);
                    add_variable(compiler, node->value, 0); // 0 = number
                }
            } else {
                // For expressions, compile the expression
                append_to_buffer(compiler, "    ; Declare variable: %s = expression result\n", node->value);
                // Compile the expression and store the result
                compile_expression(compiler, node->left);
                // After compiling expression, result should be in RAX, store it
                int var_offset = -(compiler->var_count * 8);
                append_to_buffer(compiler, "    mov DWORD PTR [rbp%d], eax\n",
                                var_offset);
                add_variable(compiler, node->value, 0); // 0 = number (for expressions)
            }
        }
    } else if (compiler->output_mode == OUTPUT_ELF) {
        // For ELF mode, handle variable declarations in machine code
        if (node->left != NULL) {
            if (node->left->type == NUMBER_NODE) {
                // For number variables in ELF mode
                int32_t value = atoi(node->left->value);
                if (compiler->machine_code) {
                    encode_mov_rax_imm32(compiler->machine_code, value);
                    // Store to memory location (need to track variable location)
                    // For now using placeholder offset
                    encode_mov_memory_from_rax(compiler->machine_code, -(compiler->var_count * 8));
                }
            } else if (node->left->type == IDENTIFIER_NODE) {
                if (node->left->value[0] == '"' && node->left->value[strlen(node->left->value)-1] == '"') {
                    // String literal assignment in ELF mode
                    char* label = create_string_label(compiler, node->left->value);
                    append_to_buffer(compiler, "; String variable declaration not fully implemented in ELF mode\n");
                    add_variable(compiler, node->value, 1); // 1 = string
                } else {
                    // Variable assignment from another variable in ELF mode
                    // Load the value of the source variable and store it
                    compile_expression(compiler, node->left);
                    // Store result to the new variable's location
                    encode_mov_memory_from_rax(compiler->machine_code, -(compiler->var_count * 8));
                }
            } else {
                // For expressions in ELF mode
                compile_expression(compiler, node->left);
                // Store the expression result to the variable's location
                encode_mov_memory_from_rax(compiler->machine_code, -(compiler->var_count * 8));
            }
            add_variable(compiler, node->value, 0); // Track the variable
        }
    }
}

// Static counter to prevent infinite recursion in AST traversal
static int recursion_depth = 0;
#define MAX_RECURSION_DEPTH 1000

void compile_ast_to_c_internal(Compiler* compiler, ASTNode* node, int inside_function) {
    if (node == NULL) return;

    // Prevent infinite recursion by limiting recursion depth
    if (recursion_depth > MAX_RECURSION_DEPTH) {
        fprintf(stderr, "Recursion depth exceeded - possible infinite loop in AST\n");
        return;
    }
    recursion_depth++;

    switch (node->type) {
        case PROGRAM_NODE:
            if (!inside_function) {
                // Only process program node if we're not already inside a function
                compile_program_node(compiler, node);
            } else {
                // Process statements sequentially when inside a function
                ASTNode* current = node->left;
                while (current != NULL) {
                    compile_ast_to_c_internal(compiler, current, inside_function);
                    if (current->right != NULL) {
                        current = current->right;
                    } else {
                        break;
                    }
                }
            }
            break;

        case FN_CALL_NODE:
            compile_function_call_node(compiler, node);
            break;

        case FN_DECL_NODE:
        case FN_DECL_SPANISH_NODE:  // CANCION case
            compile_function_decl_node(compiler, node);
            break;

        case IDENTIFIER_NODE:
            if (compiler->output_mode == OUTPUT_C) {
                if (!inside_function) {
                    write_indentation(compiler);
                    fprintf(compiler->output_file, "// Identifier: %s\n", node->value);
                } else {
                    // In a function context, identifiers might be variables
                    write_indentation(compiler);
                    fprintf(compiler->output_file, "// Using variable: %s\n", node->value);
                }
            } else if (compiler->output_mode == OUTPUT_ASM) {
                // For assembly, we may add some comments or handle differently
                append_to_buffer(compiler, "; Identifier: %s\n", node->value);
            } else if (compiler->output_mode == OUTPUT_ELF) {
                // For ELF, we might need to handle identifier use in machine code
                // For now, we'll just note this requires full implementation
            }
            break;

        case NUMBER_NODE:
            if (compiler->output_mode == OUTPUT_C) {
                if (!inside_function) {
                    write_indentation(compiler);
                    fprintf(compiler->output_file, "// Number: %s\n", node->value);
                } else {
                    // In a function context, numbers are values
                    write_indentation(compiler);
                    fprintf(compiler->output_file, "// Value: %s\n", node->value);
                }
            } else if (compiler->output_mode == OUTPUT_ASM) {
                append_to_buffer(compiler, "; Number: %s\n", node->value);
            } else if (compiler->output_mode == OUTPUT_ELF) {
                // For ELF mode, this might be used in immediate values
                // For now, placeholder
            }
            break;

        case VAR_DECL_SPANISH_NODE:
            compile_var_decl_node(compiler, node, 1);  // 1 for Spanish (decreto)
            break;

        case VAR_DECL_NODE:
            compile_var_decl_node(compiler, node, 0);  // 0 for English (let)
            break;

        case IF_SPANISH_NODE:
            if (compiler->output_mode == OUTPUT_C) {
                write_indentation(compiler);
                fprintf(compiler->output_file, "// If statement\n");
                // For now, just print the condition
                if (node->left != NULL) {
                    fprintf(compiler->output_file, "    // Condition: ... \n");
                }
            } else if (compiler->output_mode == OUTPUT_ASM) {
                // Generate assembly for if statement
                static int if_counter = 0;
                int current_if = if_counter++;

                append_to_buffer(compiler, "    ; If statement\n");

                // Evaluate condition (assuming it results in a value in EAX)
                if (node->left != NULL) {
                    compile_expression(compiler, node->left);
                    // Compare with 0 (if result != 0, condition is true)
                    append_to_buffer(compiler, "    cmp eax, 0\n");
                    append_to_buffer(compiler, "    je .Lelse_%d  ; Jump to else if condition is false\n", current_if);

                    // Process if-body
                    if (node->right != NULL) {
                        // This would be the if-then part
                        compile_ast_to_c_internal(compiler, node->right, inside_function);
                    }

                    append_to_buffer(compiler, "    jmp .Lend_%d   ; Jump to end\n", current_if);
                    append_to_buffer(compiler, ".Lelse_%d:\n", current_if);
                    append_to_buffer(compiler, ".Lend_%d:\n", current_if);
                }
            } else if (compiler->output_mode == OUTPUT_ELF) {
                // For ELF mode, generate actual machine code for conditionals
                if (compiler->machine_code && node->left != NULL) {
                    static int if_counter = 0;
                    int current_if = if_counter++;

                    // Evaluate the condition expression (result should be in RAX)
                    compile_expression(compiler, node->left);

                    // Compare with 0: CMP RAX, 0
                    uint8_t cmp_code[] = {0x48, 0x83, 0xF8, 0x00}; // CMP RAX, 0
                    append_bytes(compiler->machine_code, cmp_code, 4);

                    // Conditional jump: JZ (Jump if Zero) to else part
                    // We'll need to patch the address later, so store a placeholder
                    uint8_t jz_code[] = {0x0F, 0x84, 0x00, 0x00, 0x00, 0x00}; // JZ rel32 (placeholder)
                    int jump_pos = compiler->machine_code->size;
                    append_bytes(compiler->machine_code, jz_code, 6);

                    // Process if-body (the code to execute if condition is true)
                    if (node->right != NULL) {
                        compile_ast_to_c_internal(compiler, node->right, inside_function);
                    }

                    // At this point, we'd need to calculate the jump distance for the JZ
                    // and patch the instruction. For now, this is a basic implementation.
                }
            }
            break;

        case WHILE_SPANISH_NODE:
            if (compiler->output_mode == OUTPUT_C) {
                write_indentation(compiler);
                fprintf(compiler->output_file, "// While loop\n");
                // For now, just print the condition
                if (node->left != NULL) {
                    fprintf(compiler->output_file, "    // Condition: ... \n");
                }
            } else if (compiler->output_mode == OUTPUT_ASM) {
                // Generate assembly for while loop
                static int while_counter = 0;
                int current_while = while_counter++;

                append_to_buffer(compiler, ".Lwhile_start_%d:\n", current_while);

                // Evaluate condition (assuming it results in a value in EAX)
                if (node->left != NULL) {
                    compile_expression(compiler, node->left);
                    // Compare with 0 (while result != 0, continue loop)
                    append_to_buffer(compiler, "    cmp eax, 0\n");
                    append_to_buffer(compiler, "    je .Lwhile_end_%d  ; Jump to end if condition is false\n", current_while);

                    // Process loop body
                    if (node->right != NULL) {
                        compile_ast_to_c_internal(compiler, node->right, inside_function);
                    }

                    // Jump back to start of loop
                    append_to_buffer(compiler, "    jmp .Lwhile_start_%d\n", current_while);
                    append_to_buffer(compiler, ".Lwhile_end_%d:\n", current_while);
                }
            } else if (compiler->output_mode == OUTPUT_ELF) {
                // For ELF mode, generate actual machine code for loops
                if (compiler->machine_code && node->left != NULL) {
                    static int while_counter = 0;
                    int current_while = while_counter++;

                    int loop_start_pos = compiler->machine_code->size; // Remember start position

                    // Evaluate the condition expression (result should be in RAX)
                    compile_expression(compiler, node->left);

                    // Compare with 0: CMP RAX, 0
                    uint8_t cmp_code[] = {0x48, 0x83, 0xF8, 0x00}; // CMP RAX, 0
                    append_bytes(compiler->machine_code, cmp_code, 4);

                    // Conditional jump: JZ (Jump if Zero) to end of loop
                    uint8_t jz_code[] = {0x0F, 0x84, 0x00, 0x00, 0x00, 0x00}; // JZ rel32 (placeholder)
                    int jz_pos = compiler->machine_code->size;
                    append_bytes(compiler->machine_code, jz_code, 6);

                    // Process loop body
                    if (node->right != NULL) {
                        compile_ast_to_c_internal(compiler, node->right, inside_function);
                    }

                    // Jump back to start of loop
                    int loop_end_pos = compiler->machine_code->size; // Position after loop body
                    uint8_t jmp_back_code[] = {0xE9, 0x00, 0x00, 0x00, 0x00}; // JMP rel32 (placeholder)
                    int jmp_pos = compiler->machine_code->size;
                    append_bytes(compiler->machine_code, jmp_back_code, 5);

                    // Now calculate and patch the jump addresses
                    // Calculate distance from after the JZ instruction to the end of the loop (after JMP)
                    int32_t jz_target_offset = (jmp_pos + 5) - (jz_pos + 6); // Distance to instruction after JMP
                    // Patch the JZ instruction's operand (bytes 2-5)
                    memcpy(compiler->machine_code->code + jz_pos + 2, &jz_target_offset, 4);

                    // Calculate distance from after the JMP instruction back to the start of the loop
                    int32_t jmp_target_offset = loop_start_pos - (jmp_pos + 5); // jmp_pos + 5 is the position after JMP instruction
                    // Patch the JMP instruction's operand (bytes 1-4)
                    memcpy(compiler->machine_code->code + jmp_pos + 1, &jmp_target_offset, 4);
                }
            }
            break;

        default:
            if (compiler->output_mode == OUTPUT_C) {
                write_indentation(compiler);
                fprintf(compiler->output_file, "// Node type: %d\n", node->type);
            } else if (compiler->output_mode == OUTPUT_ASM) {
                append_to_buffer(compiler, "; Node type: %d\n", node->type);
            } else if (compiler->output_mode == OUTPUT_ELF) {
                // For ELF mode, this would need proper machine code generation
            }
            break;
    }

    recursion_depth--;  // Decrement counter when exiting the function
}

void compile_ast_to_c(Compiler* compiler, ASTNode* node, TokenStream* tokens) {
    if (node == NULL) return;

    if (compiler->output_mode == OUTPUT_ASM) {
        // For assembly mode, we collect everything in the buffer first
        // then write the complete file with proper structure at the end
        compile_ast_to_c_internal(compiler, node, 0);  // 0 for not inside a function yet
    } else {
        // For C mode, continue with the current approach
        compile_ast_to_c_internal(compiler, node, 0);  // 0 for not inside a function yet
    }
}

int compile_viva_to_c(const char* viva_code, const char* c_output_file) {
    // First tokenize and parse the Viva code
    TokenStream* tokens = tokenize(viva_code);
    ASTNode* ast = parse_program(tokens);

    // Initialize the compiler
    Compiler* compiler = init_compiler(c_output_file, OUTPUT_C);
    if (compiler == NULL) {
        free_token_stream(tokens);
        free_ast_node(ast);
        return -1;
    }

    // Generate C code from the AST
    if (ast != NULL) {
        compile_ast_to_c(compiler, ast, tokens);
    }

    // Clean up
    free_compiler(compiler);
    free_token_stream(tokens);
    free_ast_node(ast);

    return 0;
}

int compile_viva_to_asm(const char* viva_code, const char* asm_output_file) {
    // First tokenize and parse the Viva code
    TokenStream* tokens = tokenize(viva_code);
    ASTNode* ast = parse_program(tokens);

    // Initialize the compiler for assembly output
    Compiler* compiler = init_compiler(asm_output_file, OUTPUT_ASM);
    if (compiler == NULL) {
        free_token_stream(tokens);
        free_ast_node(ast);
        return -1;
    }

    // Generate assembly code from the AST
    if (ast != NULL) {
        compile_ast_to_c(compiler, ast, tokens);
    }

    // Clean up
    free_compiler(compiler);
    free_token_stream(tokens);
    free_ast_node(ast);

    return 0;
}

int compile_viva_to_elf(const char* viva_code, const char* elf_output_file) {
    // First tokenize and parse the Viva code
    TokenStream* tokens = tokenize(viva_code);
    ASTNode* ast = parse_program(tokens);

    // Initialize the compiler for ELF output (Linux default)
    Compiler* compiler = init_compiler(elf_output_file, OUTPUT_ELF);
    if (compiler == NULL) {
        free_token_stream(tokens);
        free_ast_node(ast);
        return -1;
    }

    // Set platform to Linux (default for ELF)
    compiler->platform_target = PLATFORM_LINUX;

    // Generate ELF object code from the AST
    if (ast != NULL) {
        compile_ast_to_c(compiler, ast, tokens);
    }

    // Clean up
    free_compiler(compiler);
    free_token_stream(tokens);
    free_ast_node(ast);

    return 0;
}

int compile_viva_to_platform(const char* viva_code, const char* output_file, PlatformTarget platform) {
    // First tokenize and parse the Viva code
    TokenStream* tokens = tokenize(viva_code);
    ASTNode* ast = parse_program(tokens);

    // Initialize the compiler for machine code output
    Compiler* compiler = init_compiler(output_file, OUTPUT_ELF);
    if (compiler == NULL) {
        free_token_stream(tokens);
        free_ast_node(ast);
        return -1;
    }

    // Set the specific platform target
    compiler->platform_target = platform;

    // Generate platform-specific object code from the AST
    if (ast != NULL) {
        compile_ast_to_c(compiler, ast, tokens);
    }

    // Clean up
    free_compiler(compiler);
    free_token_stream(tokens);
    free_ast_node(ast);

    return 0;
}

void generate_elf_file(Compiler* compiler) {
    if (compiler->output_mode != OUTPUT_ELF) return;

    // Create proper ELF file structure
    ELFFile* elf = init_elf_file();
    if (!elf) return;

    // Create text section with machine code
    if (compiler->machine_code && compiler->machine_code->size > 0) {
        create_text_section(elf, compiler->machine_code);
    } else {
        // If no machine code was generated during compilation, create a minimal function
        MachineCode* mc = init_machine_code();
        encode_push_rbp(mc);
        encode_mov_rbp_rsp(mc);
        encode_mov_rax_imm32(mc, 0);  // Return 0
        encode_pop_rbp(mc);
        encode_ret(mc);

        create_text_section(elf, mc);
        free_machine_code(mc);
    }

    // Add symbol table and string table
    create_symbol_table(elf);

    // Create the complete ELF file
    write_complete_elf_file(elf, compiler->output_filename);

    // Clean up
    free_elf_file(elf);
}

// Machine code generation for ELF output
MachineCode* init_machine_code() {
    MachineCode* mc = malloc(sizeof(MachineCode));
    mc->capacity = 4096;
    mc->size = 0;
    mc->code = malloc(mc->capacity);
    mc->reloc_count = 0;
    mc->reloc_capacity = 16;  // Start with space for 16 relocations
    mc->relocations = malloc(mc->reloc_capacity * sizeof(Elf64_Rela));
    return mc;
}

void free_machine_code(MachineCode* mc) {
    if (mc) {
        free(mc->code);
        if (mc->relocations) {
            free(mc->relocations);
        }
        free(mc);
    }
}

int append_bytes(MachineCode* mc, const uint8_t* bytes, size_t len) {
    if (mc->size + len > mc->capacity) {
        return -1; // Buffer too small
    }
    memcpy(mc->code + mc->size, bytes, len);
    mc->size += len;
    return 0;
}

// More comprehensive x86-64 instruction encoder
int encode_push_rbp(MachineCode* mc) {
    uint8_t code[] = {0x55};
    return append_bytes(mc, code, 1);
}

int encode_mov_rbp_rsp(MachineCode* mc) {
    uint8_t code[] = {0x48, 0x89, 0xE5};
    return append_bytes(mc, code, 3);
}

int encode_mov_rax_imm32(MachineCode* mc, int32_t value) {
    uint8_t code[7];
    code[0] = 0x48;  // REX prefix for 64-bit
    code[1] = 0xC7;  // MOV r32, imm32
    code[2] = 0xC0;  // ModR/M for RAX
    // Immediate value in little-endian
    *(int32_t*)(code + 3) = value;
    return append_bytes(mc, code, 7);
}

int encode_pop_rbp(MachineCode* mc) {
    uint8_t code[] = {0x5D};
    return append_bytes(mc, code, 1);
}

int encode_ret(MachineCode* mc) {
    uint8_t code[] = {0xC3};
    return append_bytes(mc, code, 1);
}

int encode_mov_rdi_imm64(MachineCode* mc, uint64_t value) {
    // MOV RDI, imm64 (requires two instructions on x86-64)
    // MOV RDI, value (first set lower 32 bits)
    uint8_t code1[] = {0x48, 0xC7, 0xC7, 0x00, 0x00, 0x00, 0x00};  // MOV EDI, imm32
    // Set the immediate value (this is just for 32-bit values for now)
    *(uint32_t*)(code1 + 3) = (uint32_t)value;
    int result = append_bytes(mc, code1, 7);

    if (result != 0) return result;

    // For full 64-bit, we'd need: MOV RDI, imm64 (using MOV REX.W+B + MOV)
    // This is a simplified implementation
    return 0;
}

int encode_mov_rbp_rdi(MachineCode* mc) {  // For function parameters
    // Placeholder - this would load a parameter into RDI register
    // MOV RDI, [RBP+N] or similar - this is a placeholder
    uint8_t code[] = {0x48, 0x89, 0x7D, 0xF8};  // MOV [RBP-8], RDI (example)
    return append_bytes(mc, code, 4);
}

// Encode ADD RAX, RBX (add RAX and RBX, store result in RAX)
int encode_add_rax_rbx(MachineCode* mc) {
    uint8_t code[] = {0x48, 0x01, 0xD8};  // ADD RAX, RBX
    return append_bytes(mc, code, 3);
}

// Encode MOV RAX, [memory_location] - load value from memory to RAX
int encode_mov_rax_from_memory(MachineCode* mc, int offset_from_rbp) {
    // MOV RAX, [RBP + offset] - load from stack location
    uint8_t code[] = {0x48, 0x8B, 0x85};  // MOV RAX, [RBP+disp32]
    uint8_t offset_bytes[4];
    *(int32_t*)offset_bytes = offset_from_rbp;

    // Append the instruction
    int result = append_bytes(mc, code, 3);
    if (result != 0) return result;
    return append_bytes(mc, offset_bytes, 4);
}

// Encode MOV [memory_location], RAX - store RAX to memory
int encode_mov_memory_from_rax(MachineCode* mc, int offset_from_rbp) {
    // MOV [RBP + offset], RAX - store to stack location
    uint8_t code[] = {0x48, 0x89, 0x85};  // MOV [RBP+disp32], RAX
    uint8_t offset_bytes[4];
    *(int32_t*)offset_bytes = offset_from_rbp;

    int result = append_bytes(mc, code, 3);
    if (result != 0) return result;
    return append_bytes(mc, offset_bytes, 4);
}

// Encode MOV RBX, immediate32 value
int encode_mov_rbx_imm32(MachineCode* mc, int32_t value) {
    uint8_t code[7];
    code[0] = 0x48;  // REX prefix for 64-bit
    code[1] = 0xC7;  // MOV r32, imm32
    code[2] = 0xCB;  // ModR/M for RBX
    // Immediate value in little-endian
    *(int32_t*)(code + 3) = value;
    return append_bytes(mc, code, 7);
}

// Encode SUB RAX, RBX (subtract RBX from RAX, store result in RAX)
int encode_sub_rax_rbx(MachineCode* mc) {
    uint8_t code[] = {0x48, 0x29, 0xD8};  // SUB RAX, RBX
    return append_bytes(mc, code, 3);
}

// Encode MUL RBX (multiply RAX by RBX, result in RAX/RDX)
int encode_mul_rbx(MachineCode* mc) {
    uint8_t code[] = {0x48, 0x0F, 0xAF, 0xC3};  // IMUL RAX, RBX
    return append_bytes(mc, code, 4);
}

// Encode DIV RBX (divide RAX by RBX, result in RAX)
int encode_div_rbx(MachineCode* mc) {
    // For division, we need to set up RDX to 0 first
    uint8_t setup_code[] = {0x48, 0x31, 0xD2};  // XOR RDX, RDX
    uint8_t div_code[] = {0x48, 0xF7, 0xF3};   // DIV RBX
    int result = append_bytes(mc, setup_code, 3);
    if (result != 0) return result;
    return append_bytes(mc, div_code, 3);
}

// For function call instructions (simplified) - works with MachineCode*
int encode_call_printf(MachineCode* mc) {
    // This is a complex operation that requires relocation
    // For now we'll create a placeholder CALL instruction
    // This function is used in contexts where only MachineCode is available
    uint8_t code[] = {0xE8, 0x00, 0x00, 0x00, 0x00};  // CALL rel32 with 0 offset placeholder
    return append_bytes(mc, code, 5);
}

// Encode call to external function
int encode_call_external(MachineCode* mc) {
    // Create a placeholder for a CALL instruction
    // The actual address will be resolved via relocation
    uint8_t code[] = {0xE8, 0x00, 0x00, 0x00, 0x00};  // CALL rel32 with 0 offset placeholder
    return append_bytes(mc, code, 5);
}

void free_compiler(Compiler* compiler) {
    if (compiler != NULL) {
        if (compiler->output_file != NULL) {
            fclose(compiler->output_file);

            if (compiler->output_mode == OUTPUT_ASM) {
                // For assembly mode, we need to write everything in the correct order:
                // 1. Complete data section with all strings
                // 2. Code section from the buffer

                // Now write the complete file with proper structure
                FILE* final_file = fopen(compiler->output_filename, "w");
                if (final_file != NULL) {
                    // Write the complete header with all collected strings in data section
                    fprintf(final_file, "; Generated by Viva Colombia compiler\n");
                    fprintf(final_file, "section .data\n");
                    fprintf(final_file, "    fmt_print db \"%%s\", 10, 0\n");
                    fprintf(final_file, "    fmt_print_num db \"%%d\", 10, 0\n");
                    fprintf(final_file, "    str_simon db \"Simón Bolívar: Libertador de Colombia, Venezuela, Ecuador, Perú y Bolivia\", 10, 0\n");
                    fprintf(final_file, "    str_francisco db \"Francisco de Paula Santander y Nariño: Héroe de la independencia colombiana\", 10, 0\n");
                    fprintf(final_file, "    str_maria db \"María Cano: Líder obrera y feminista colombiana\", 10, 0\n");
                    fprintf(final_file, "    str_jorge db \"Jorge Eliécer Gaitán: Líder político y defensor del pueblo colombiano\", 10, 0\n");
                    fprintf(final_file, "    str_gabriel db \"Gabriel García Márquez: Nobel de Literatura, autor de Cien Años de Soledad\", 10, 0\n");

                    // Add all collected string literals to the data section
                    for (int i = 0; i < compiler->string_count; i++) {
                        fprintf(final_file, "    %s: db \"%s\", 0\n",
                                compiler->strings[i].label, compiler->strings[i].value);
                    }

                    fprintf(final_file, "\nsection .text\n");
                    fprintf(final_file, "    global main\n");
                    fprintf(final_file, "    extern printf\n\n");

                    // Now write the code section from buffer
                    fprintf(final_file, "%s", compiler->code_buffer);

                    fclose(final_file);
                }
            } else if (compiler->output_mode == OUTPUT_ELF) {
                // For machine code generation mode, use platform-specific output
                generate_platform_object_file(compiler);
            }
        }

        // Clean up machine code if it exists
        if (compiler->machine_code) {
            free_machine_code(compiler->machine_code);
        }

        // Clean up ELF file structure if it exists
        if (compiler->elf_file) {
            free_elf_file(compiler->elf_file);
        }

        // Clean up platform-specific data if it exists
        if (compiler->platform_specific_data) {
            // For now, just free the pointer - in a complete implementation
            // we would free Mach-O or PE file structures here
            free(compiler->platform_specific_data);
        }

        free(compiler);
    }
}

// ELF File Management Implementation
ELFFile* init_elf_file() {
    ELFFile* elf = malloc(sizeof(ELFFile));
    if (!elf) return NULL;

    // Initialize ELF header
    memset(&elf->header, 0, sizeof(Elf64_Ehdr));

    // ELF magic number
    elf->header.e_ident[0] = 0x7f;
    elf->header.e_ident[1] = 'E';
    elf->header.e_ident[2] = 'L';
    elf->header.e_ident[3] = 'F';
    elf->header.e_ident[4] = ELFCLASS64;  // 64-bit
    elf->header.e_ident[5] = ELFDATA2LSB; // Little endian
    elf->header.e_ident[6] = EV_CURRENT;  // Current version
    elf->header.e_ident[7] = 0;           // OS/ABI
    elf->header.e_ident[8] = 0;           // ABI version

    elf->header.e_type = ET_REL;          // Relocatable file
    elf->header.e_machine = EM_X86_64;    // x86-64
    elf->header.e_version = EV_CURRENT;
    elf->header.e_ehsize = sizeof(Elf64_Ehdr);
    elf->header.e_shentsize = sizeof(Elf64_Shdr);
    elf->header.e_phentsize = 0;          // No program header for relocatable file

    // Initialize section management
    elf->sections = malloc(sizeof(ElfSection*) * 16); // Start with 16 sections
    elf->num_sections = 0;
    elf->text_section_idx = -1;
    elf->data_section_idx = -1;
    elf->symtab_section_idx = -1;
    elf->strtab_section_idx = -1;
    elf->shstrtab_section_idx = -1;

    return elf;
}

void free_elf_file(ELFFile* elf) {
    if (!elf) return;

    for (int i = 0; i < elf->num_sections; i++) {
        if (elf->sections[i]) {
            if (elf->sections[i]->data) {
                free(elf->sections[i]->data);
            }
            if (elf->sections[i]->name) {
                free(elf->sections[i]->name);
            }
            free(elf->sections[i]);
        }
    }

    if (elf->sections) {
        free(elf->sections);
    }
    free(elf);
}

int add_elf_section(ELFFile* elf, const char* name, uint32_t type, uint64_t flags) {
    if (elf->num_sections >= 16) return -1; // Too many sections

    ElfSection* section = malloc(sizeof(ElfSection));
    if (!section) return -1;

    section->name = malloc(strlen(name) + 1);
    if (!section->name) {
        free(section);
        return -1;
    }

    strcpy(section->name, name);
    section->type = type;
    section->flags = flags;
    section->addr = 0;
    section->offset = 0;
    section->size = 0;
    section->link = 0;
    section->info = 0;
    section->addralign = 1;
    section->entsize = 0;
    section->data = NULL;

    elf->sections[elf->num_sections] = section;

    // Track special sections by name
    if (strcmp(name, ".text") == 0) {
        elf->text_section_idx = elf->num_sections;
    } else if (strcmp(name, ".data") == 0) {
        elf->data_section_idx = elf->num_sections;
    } else if (strcmp(name, ".symtab") == 0) {
        elf->symtab_section_idx = elf->num_sections;
    } else if (strcmp(name, ".strtab") == 0) {
        elf->strtab_section_idx = elf->num_sections;
    } else if (strcmp(name, ".shstrtab") == 0) {
        elf->shstrtab_section_idx = elf->num_sections;
    }

    return elf->num_sections++;
}

// Create a text section with machine code
void create_text_section(ELFFile* elf, MachineCode* code) {
    int section_idx = add_elf_section(elf, ".text", SHT_PROGBITS, SHF_ALLOC | SHF_EXECINSTR);
    if (section_idx < 0) return;

    ElfSection* text_section = elf->sections[section_idx];
    text_section->size = code->size;
    text_section->addralign = 16; // Align to 16 bytes for x86-64
    text_section->entsize = 0; // Not applicable for PROGBITS section
    text_section->data = malloc(code->size);
    if (text_section->data) {
        memcpy(text_section->data, code->code, code->size);
    }
}

// Write the complete ELF file with proper structure
int write_complete_elf_file(ELFFile* elf, const char* filename) {
    if (!elf || !filename) return -1;

    FILE* file = fopen(filename, "wb");
    if (!file) return -1;

    // Calculate offsets for sections - section headers come after ELF header and all section data
    uint64_t sections_start_offset = sizeof(Elf64_Ehdr); // Start after ELF header
    uint64_t current_offset = sections_start_offset;

    // First pass: set up section offsets
    for (int i = 0; i < elf->num_sections; i++) {
        if (elf->sections[i]->size > 0) {
            // Align section offset
            if (current_offset % 8 != 0) {
                current_offset = (current_offset + 7) & ~7;
            }
            elf->sections[i]->offset = current_offset;
            current_offset += elf->sections[i]->size;
        }
    }

    // Section header table comes after all section data
    uint64_t section_header_table_offset = current_offset;

    // Update header fields based on section count
    elf->header.e_shnum = elf->num_sections + 1; // +1 for null section at index 0
    elf->header.e_shstrndx = elf->shstrtab_section_idx;
    elf->header.e_shoff = section_header_table_offset; // Point to section header table

    // Write ELF header
    fwrite(&elf->header, sizeof(Elf64_Ehdr), 1, file);

    // Write section data
    for (int i = 0; i < elf->num_sections; i++) {
        if (elf->sections[i]->data && elf->sections[i]->size > 0) {
            fseek(file, elf->sections[i]->offset, SEEK_SET);
            fwrite(elf->sections[i]->data, 1, elf->sections[i]->size, file);
        }
    }

    // Write section headers table at the end
    fseek(file, section_header_table_offset, SEEK_SET);

    // Write null section header (index 0)
    Elf64_Shdr null_shdr = {0};
    fwrite(&null_shdr, sizeof(Elf64_Shdr), 1, file);

    // Write actual section headers
    for (int i = 0; i < elf->num_sections; i++) {
        Elf64_Shdr shdr = {0};
        shdr.sh_name = 0; // Will be set in more complete implementation
        shdr.sh_type = elf->sections[i]->type;
        shdr.sh_flags = elf->sections[i]->flags;
        shdr.sh_addr = elf->sections[i]->addr;
        shdr.sh_offset = elf->sections[i]->offset;
        shdr.sh_size = elf->sections[i]->size;
        shdr.sh_link = elf->sections[i]->link;
        shdr.sh_info = elf->sections[i]->info;
        shdr.sh_addralign = elf->sections[i]->addralign;

        // Set appropriate entry size for different section types
        if (elf->sections[i]->type == SHT_SYMTAB) {
            shdr.sh_entsize = sizeof(Elf64_Sym);  // Size of symbol table entry
        } else if (elf->sections[i]->type == SHT_RELA) {
            shdr.sh_entsize = sizeof(uint64_t) * 4; // Size of relocation entry
        } else if (elf->sections[i]->type == SHT_STRTAB) {
            shdr.sh_entsize = 1; // Size of string table entry
        } else {
            shdr.sh_entsize = elf->sections[i]->entsize;
        }

        fwrite(&shdr, sizeof(Elf64_Shdr), 1, file);
    }

    fclose(file);
    return 0;
}

// Add a symbol to the symbol table
int add_symbol_to_table(ELFFile* elf, const char* name, uint64_t value, uint64_t size, uint8_t info, uint16_t shndx) {
    // Find the symtab and strtab sections
    if (elf->symtab_section_idx < 0 || elf->strtab_section_idx < 0) {
        return -1;
    }

    ElfSection* symtab_section = elf->sections[elf->symtab_section_idx];
    ElfSection* strtab_section = elf->sections[elf->strtab_section_idx];

    // Expand the string table to hold the new string
    size_t name_len = strlen(name) + 1; // +1 for null terminator
    uint8_t* new_strtab_data = realloc(strtab_section->data, strtab_section->size + name_len);
    if (!new_strtab_data) return -1;

    strtab_section->data = new_strtab_data;
    // Copy the string to the string table
    strcpy((char*)strtab_section->data + strtab_section->size, name);
    strtab_section->size += name_len;

    // Calculate the name's offset in the string table
    uint32_t name_offset = strtab_section->size - name_len;

    // Expand the symbol table to hold the new symbol
    size_t sym_size = sizeof(Elf64_Sym);
    uint8_t* new_symtab_data = realloc(symtab_section->data, symtab_section->size + sym_size);
    if (!new_symtab_data) return -1;

    symtab_section->data = new_symtab_data;

    // Create the symbol entry
    Elf64_Sym* sym = (Elf64_Sym*)((char*)symtab_section->data + symtab_section->size);
    sym->st_name = name_offset;
    sym->st_info = info;
    sym->st_other = 0;
    sym->st_shndx = shndx;
    sym->st_value = value;
    sym->st_size = size;

    symtab_section->size += sym_size;

    return 0;
}

// Create symbol table
void create_symbol_table(ELFFile* elf) {
    // Create string table first
    int strtab_idx = add_elf_section(elf, ".strtab", SHT_STRTAB, 0);
    if (strtab_idx < 0) return;

    // Create symbol table - link to string table
    int symtab_idx = add_elf_section(elf, ".symtab", SHT_SYMTAB, 0);
    if (symtab_idx < 0) return;

    // Update symbol table section to link to string table
    elf->sections[symtab_idx]->link = strtab_idx + 1;  // +1 because of the null section at index 0
    elf->sections[symtab_idx]->entsize = sizeof(Elf64_Sym);  // Size of each symbol entry

    // Add section header string table
    int shstrtab_idx = add_elf_section(elf, ".shstrtab", SHT_STRTAB, 0);
    if (shstrtab_idx < 0) return;

    // Update the section header string table index
    elf->header.e_shstrndx = shstrtab_idx;

    // Add NULL symbol (required at index 0 of symbol table)
    add_symbol_to_table(elf, "", 0, 0, ELF64_ST_INFO(0, 0), 0);

    // Add .text symbol if text section exists
    if (elf->text_section_idx >= 0) {
        add_symbol_to_table(elf, ".text", 0, 0,
                           ELF64_ST_INFO(STB_LOCAL, STT_SECTION),
                           elf->text_section_idx + 1);  // +1 for null section
    }

    // Add 'main' symbol (assuming our code implements main function)
    add_symbol_to_table(elf, "main", 0, 0,
                       ELF64_ST_INFO(STB_GLOBAL, STT_FUNC),
                       elf->text_section_idx + 1);  // +1 for null section
}

// Add a relocation entry
int add_relocation_entry(MachineCode* mc, uint32_t sym_index, uint32_t type, int64_t addend) {
    if (!mc) return -1;

    // Check if we need to expand the relocations array
    if (mc->reloc_count >= mc->reloc_capacity) {
        mc->reloc_capacity *= 2;
        Elf64_Rela* new_relocs = realloc(mc->relocations, mc->reloc_capacity * sizeof(Elf64_Rela));
        if (!new_relocs) return -1;
        mc->relocations = new_relocs;
    }

    // Create the relocation entry
    Elf64_Rela* reloc = &mc->relocations[mc->reloc_count];
    reloc->r_offset = mc->size;  // The current position in machine code where this relocation applies
    reloc->r_info = ELF64_R_INFO(sym_index, type);
    reloc->r_addend = addend;

    mc->reloc_count++;
    return 0;
}

// Mach-O object file structures and functions
typedef struct {
    mach_header_64 header;
    load_command* load_commands;
    int num_commands;
    // Section data
    uint8_t* text_section_data;
    size_t text_section_size;
    uint8_t* data_section_data;
    size_t data_section_size;
} MachOFile;

MachOFile* init_macho_file() {
    MachOFile* macho = malloc(sizeof(MachOFile));
    if (!macho) return NULL;

    // Initialize Mach-O header for 64-bit x86-64 object file
    macho->header.magic = MH_MAGIC_64;
    macho->header.cputype = CPU_TYPE_X86_64;
    macho->header.cpusubtype = 3; // CPU_SUBTYPE_X86_64_ALL
    macho->header.filetype = MH_OBJECT; // Relocatable object file
    macho->header.ncmds = 0;
    macho->header.sizeofcmds = 0;
    macho->header.flags = 0;
    macho->header.reserved = 0;

    macho->load_commands = malloc(sizeof(load_command) * 10); // Start with 10 commands
    macho->num_commands = 0;

    macho->text_section_data = NULL;
    macho->text_section_size = 0;
    macho->data_section_data = NULL;
    macho->data_section_size = 0;

    return macho;
}

void free_macho_file(MachOFile* macho) {
    if (!macho) return;

    if (macho->load_commands) {
        free(macho->load_commands);
    }
    if (macho->text_section_data) {
        free(macho->text_section_data);
    }
    if (macho->data_section_data) {
        free(macho->data_section_data);
    }
    free(macho);
}

// Function to write a Mach-O file
int write_macho_file(MachOFile* macho, const char* filename) {
    if (!macho || !filename) return -1;

    FILE* file = fopen(filename, "wb");
    if (!file) return -1;

    // Write the mach header
    fwrite(&macho->header, sizeof(mach_header_64), 1, file);

    // Write load commands
    // (In a full implementation, this would write the actual segment and section commands)

    // Write section data
    if (macho->text_section_data && macho->text_section_size > 0) {
        fwrite(macho->text_section_data, 1, macho->text_section_size, file);
    }

    fclose(file);
    return 0;
}

// PE/COFF object file structures and functions
typedef struct {
    uint32_t signature;  // IMAGE_NT_SIGNATURE
    IMAGE_FILE_HEADER file_header;
    IMAGE_SECTION_HEADER* section_headers;
    int num_sections;
    // Section data
    uint8_t* text_section_data;
    size_t text_section_size;
    uint8_t* data_section_data;
    size_t data_section_size;
} PEFile;

PEFile* init_pe_file() {
    PEFile* pe = malloc(sizeof(PEFile));
    if (!pe) return NULL;

    pe->signature = IMAGE_NT_SIGNATURE;

    // Initialize file header for 64-bit object file
    pe->file_header.Machine = 0x8664; // IMAGE_FILE_MACHINE_AMD64
    pe->file_header.NumberOfSections = 0;
    pe->file_header.TimeDateStamp = 0;
    pe->file_header.PointerToSymbolTable = 0;
    pe->file_header.NumberOfSymbols = 0;
    pe->file_header.SizeOfOptionalHeader = 0;
    pe->file_header.Characteristics = 0x0200; // IMAGE_FILE_DLL

    pe->section_headers = malloc(sizeof(IMAGE_SECTION_HEADER) * 10); // Start with 10 sections
    pe->num_sections = 0;

    pe->text_section_data = NULL;
    pe->text_section_size = 0;
    pe->data_section_data = NULL;
    pe->data_section_size = 0;

    return pe;
}

void free_pe_file(PEFile* pe) {
    if (!pe) return;

    if (pe->section_headers) {
        free(pe->section_headers);
    }
    if (pe->text_section_data) {
        free(pe->text_section_data);
    }
    if (pe->data_section_data) {
        free(pe->data_section_data);
    }
    free(pe);
}

// Function to write a PE file
int write_pe_file(PEFile* pe, const char* filename) {
    if (!pe || !filename) return -1;

    FILE* file = fopen(filename, "wb");
    if (!file) return -1;

    // Write NT signature
    fwrite(&pe->signature, sizeof(uint32_t), 1, file);

    // Write file header
    fwrite(&pe->file_header, sizeof(IMAGE_FILE_HEADER), 1, file);

    // Write section headers
    // (In a full implementation, this would write actual section headers)

    // Write section data
    if (pe->text_section_data && pe->text_section_size > 0) {
        fwrite(pe->text_section_data, 1, pe->text_section_size, file);
    }

    fclose(file);
    return 0;
}

// Function to create platform-specific object file
int generate_platform_object_file(Compiler* compiler) {
    if (!compiler) return -1;

    switch (compiler->platform_target) {
        case PLATFORM_LINUX:
            generate_elf_file(compiler);
            break;
        case PLATFORM_MACOS:
            {
                // Create Mach-O file
                MachOFile* macho = init_macho_file();
                if (macho && compiler->machine_code) {
                    macho->text_section_data = malloc(compiler->machine_code->size);
                    if (macho->text_section_data) {
                        memcpy(macho->text_section_data, compiler->machine_code->code, compiler->machine_code->size);
                        macho->text_section_size = compiler->machine_code->size;
                        write_macho_file(macho, compiler->output_filename);
                    }
                }
                if (macho) free_macho_file(macho);
            }
            break;
        case PLATFORM_WINDOWS:
            {
                // Create PE file
                PEFile* pe = init_pe_file();
                if (pe && compiler->machine_code) {
                    pe->text_section_data = malloc(compiler->machine_code->size);
                    if (pe->text_section_data) {
                        memcpy(pe->text_section_data, compiler->machine_code->code, compiler->machine_code->size);
                        pe->text_section_size = compiler->machine_code->size;
                        write_pe_file(pe, compiler->output_filename);
                    }
                }
                if (pe) free_pe_file(pe);
            }
            break;
        default:
            generate_elf_file(compiler);  // Fallback to ELF
            break;
    }

    return 0;
}

