// src/compiler.c - EXPANDED for Phase 4
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <stdint.h>
#include "../include/lexer.h"
#include "../include/parser.h"
#include "../include/compiler.h"
#include "../include/machine_code.h"
#include "../include/macho.h"
#include "../include/pe_coff.h"

#define MAX_VARS 100
#define MAX_STRS 100
#define MAX_BUF 16384
#define MAX_LABELS 256

typedef enum { OUT_C, OUT_ASM, OUT_ELF } OutMode;

typedef struct { char name[64]; int is_str; int offset; } Var;
typedef struct { char val[256]; char lbl[32]; int offset; } Str;
typedef struct { char name[32]; int offset; } Label;

typedef struct {
    FILE* f;
    OutMode mode;
    PlatformTarget plat;
    int indent;
    Var vars[MAX_VARS];
    int nvar;
    Str strs[MAX_STRS];
    int nstr;
    Label labels[MAX_LABELS];
    int nlbl;
    char buf[MAX_BUF];
    int bufpos;
    char outname[256];
    MachineCode* mc;
    ELFFile* elf;
    int stack_off;
    int data_size;
} Compiler;

// Forward declarations
static void compile_node(Compiler* c, ASTNode* n);
static void compile_expr(Compiler* c, ASTNode* n);
static void compile_expr_to_rax(Compiler* c, ASTNode* n);

// === EMIT HELPERS ===
static void emit(Compiler* c, const char* fmt, ...) {
    va_list a;
    va_start(a, fmt);
    if (c->mode == OUT_ASM) {
        int r = MAX_BUF - c->bufpos;
        int n = vsnprintf(c->buf + c->bufpos, r, fmt, a);
        if (n > 0 && n < r) c->bufpos += n;
    } else if (c->mode == OUT_C) {
        vfprintf(c->f, fmt, a);
    }
    va_end(a);
}

static void indent(Compiler* c) {
    for (int i = 0; i < c->indent; i++) emit(c, "    ");
}

// === VARIABLE MANAGEMENT ===
static int find_var(Compiler* c, const char* name) {
    for (int i = 0; i < c->nvar; i++)
        if (strcmp(c->vars[i].name, name) == 0) return i;
    return -1;
}

static int add_var(Compiler* c, const char* name, int is_str) {
    if (c->nvar >= MAX_VARS) return -1;
    strncpy(c->vars[c->nvar].name, name, 63);
    c->vars[c->nvar].is_str = is_str;
    c->stack_off -= 8;
    c->vars[c->nvar].offset = c->stack_off;
    return c->nvar++;
}

static int get_var_off(Compiler* c, const char* name) {
    int i = find_var(c, name);
    return (i >= 0) ? c->vars[i].offset : -8;
}

static int is_var_str(Compiler* c, const char* name) {
    int i = find_var(c, name);
    return (i >= 0) ? c->vars[i].is_str : 0;
}

// === STRING MANAGEMENT ===
static char* add_str(Compiler* c, const char* s) {
    if (c->nstr >= MAX_STRS) return "str_err";
    static int cnt = 0;
    snprintf(c->strs[c->nstr].lbl, 32, "str_%d", cnt++);
    
    const char* p = (s[0] == '"') ? s + 1 : s;
    strncpy(c->strs[c->nstr].val, p, 255);
    size_t len = strlen(c->strs[c->nstr].val);
    if (len > 0 && c->strs[c->nstr].val[len-1] == '"')
        c->strs[c->nstr].val[len-1] = '\0';
    
    c->strs[c->nstr].offset = c->data_size;
    c->data_size += strlen(c->strs[c->nstr].val) + 1;
    
    return c->strs[c->nstr++].lbl;
}

static int get_str_offset(Compiler* c, const char* lbl) {
    for (int i = 0; i < c->nstr; i++)
        if (strcmp(c->strs[i].lbl, lbl) == 0) return c->strs[i].offset;
    return 0;
}

// === COMPILER INIT/FINISH ===
static Compiler* init_compiler(const char* outfile, OutMode mode) {
    Compiler* c = calloc(1, sizeof(Compiler));
    if (!c) return NULL;
    c->mode = mode;
    c->plat = PLATFORM_LINUX;
    strncpy(c->outname, outfile, 255);
    
    if (mode == OUT_ELF) {
        c->mc = init_machine_code();
        c->elf = init_elf_file();
    }
    
    c->f = fopen(outfile, "wb");
    if (!c->f) { free(c); return NULL; }
    
    if (mode == OUT_C) {
        fprintf(c->f,
            "// Generated by Viva Colombia compiler\n"
            "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n"
            "void prt(char* s){printf(\"%%s\",s);}\n"
            "void prtln(char* s){printf(\"%%s\\n\",s);}\n"
            "void prtnum(int n){printf(\"%%d\",n);}\n"
            "void prtlnnum(int n){printf(\"%%d\\n\",n);}\n"
            "void bolivar(){printf(\"Simon Bolivar: Libertador\\n\");}\n"
            "void narino(){printf(\"Francisco Narino: Heroe\\n\");}\n"
            "void cano(){printf(\"Maria Cano: Lider\\n\");}\n"
            "void gaitan(){printf(\"Jorge Gaitan: Lider politico\\n\");}\n"
            "void garcia(){printf(\"Gabriel Garcia Marquez: Nobel\\n\");}\n\n");
    } else if (mode == OUT_ASM) {
        fprintf(c->f,
            "; Generated by Viva Colombia\n"
            "section .data\n"
            "    fmt_s db \"%%s\",10,0\n"
            "    fmt_d db \"%%d\",10,0\n");
    }
    return c;
}

static void write_asm_strings(Compiler* c) {
    if (c->mode != OUT_ASM) return;
    for (int i = 0; i < c->nstr; i++) {
        fprintf(c->f, "    %s db \"%s\",0\n", c->strs[i].lbl, c->strs[i].val);
    }
    fprintf(c->f,
        "section .text\n"
        "    global main\n"
        "    extern printf\n\n");
}

static void write_elf_data_section(Compiler* c) {
    if (c->mode != OUT_ELF || c->nstr == 0) return;
    
    uint8_t* data = calloc(1, c->data_size + 1);
    if (!data) return;
    
    int off = 0;
    for (int i = 0; i < c->nstr; i++) {
        size_t len = strlen(c->strs[i].val);
        memcpy(data + off, c->strs[i].val, len);
        data[off + len] = 0;
        off += len + 1;
    }
    
    create_data_section(c->elf, data, c->data_size);
    free(data);
}

static void finish_compiler(Compiler* c) {
    if (!c) return;

    if (c->mode == OUT_ASM) {
        write_asm_strings(c);
        if (c->bufpos > 0)
            fwrite(c->buf, 1, c->bufpos, c->f);
    }

    if (c->mode == OUT_ELF && c->mc) {
        // Close the file first - platform writers will create their own
        if (c->f) {
            fclose(c->f);
            c->f = NULL;
        }

        // Use platform-specific object file writer
        switch (c->plat) {
            case PLATFORM_MACOS:
                compile_to_macho(c->mc, c->outname);
                break;
            case PLATFORM_WINDOWS:
                compile_to_pecoff(c->mc, c->outname);
                break;
            case PLATFORM_LINUX:
            default:
                // Use ELF for Linux
                if (c->elf) {
                    write_elf_data_section(c);
                    create_text_section(c->elf, c->mc);
                    create_symbol_table(c->elf);
                    write_complete_elf_file(c->elf, c->outname);
                }
                break;
        }
    }

    if (c->f) fclose(c->f);
    if (c->mc) free_machine_code(c->mc);
    if (c->elf) free_elf_file(c->elf);
    free(c);
}

// === EXPRESSION COMPILATION ===
static void compile_expr(Compiler* c, ASTNode* n) {
    if (!n) return;
    
    if (n->type == NUMBER_NODE) {
        if (c->mode == OUT_C) emit(c, "%s", n->value);
        else if (c->mode == OUT_ASM) emit(c, "    mov rax, %s\n", n->value);
        else if (c->mc) encode_mov_rax_imm32(c->mc, atoi(n->value));
    }
    else if (n->type == STRING_LITERAL_NODE) {
        if (c->mode == OUT_C) emit(c, "%s", n->value);
        else if (c->mode == OUT_ASM) {
            char* l = add_str(c, n->value);
            emit(c, "    lea rax, [%s]\n", l);
        }
        else if (c->mc) {
            char* l = add_str(c, n->value);
            int off = get_str_offset(c, l);
            encode_lea_rax_rip_rel(c->mc, off);
        }
    }
    else if (n->type == IDENTIFIER_NODE) {
        if (n->value && n->value[0] == '"') {
            if (c->mode == OUT_C) emit(c, "%s", n->value);
            else if (c->mode == OUT_ASM) {
                char* l = add_str(c, n->value);
                emit(c, "    lea rax, [%s]\n", l);
            }
            else if (c->mc) {
                char* l = add_str(c, n->value);
                int off = get_str_offset(c, l);
                encode_lea_rax_rip_rel(c->mc, off);
            }
        } else {
            if (c->mode == OUT_C) emit(c, "%s", n->value);
            else if (c->mode == OUT_ASM) {
                int off = get_var_off(c, n->value);
                emit(c, "    mov rax, [rbp%+d]\n", off);
            }
            else if (c->mc) {
                int off = get_var_off(c, n->value);
                encode_mov_rax_from_memory(c->mc, off);
            }
        }
    }
    else if (n->type == ARRAY_ACCESS_NODE) {
        // Array access: arr[index]
        if (c->mode == OUT_C) {
            emit(c, "%s[", n->value);
            compile_expr(c, n->left);
            emit(c, "]");
        }
        else if (c->mode == OUT_ASM) {
            // TODO: implement array access in assembly
            emit(c, "    ; array access %s[...]\n", n->value);
        }
        else if (c->mc) {
            // TODO: implement array access in machine code
        }
    }
    else if (n->type == BINARY_OP_NODE) {
        if (c->mode == OUT_C) {
            emit(c, "(");
            compile_expr(c, n->left);
            emit(c, " %s ", n->value ? n->value : "+");
            compile_expr(c, n->right);
            emit(c, ")");
        }
        else if (c->mode == OUT_ASM) {
            compile_expr(c, n->left);
            emit(c, "    push rax\n");
            compile_expr(c, n->right);
            emit(c, "    mov rbx, rax\n    pop rax\n");
            
            if (!n->value) return;
            if (strcmp(n->value, "+") == 0) emit(c, "    add rax, rbx\n");
            else if (strcmp(n->value, "-") == 0) emit(c, "    sub rax, rbx\n");
            else if (strcmp(n->value, "*") == 0) emit(c, "    imul rax, rbx\n");
            else if (strcmp(n->value, "/") == 0) emit(c, "    xor rdx,rdx\n    idiv rbx\n");
            else if (strcmp(n->value, "%") == 0) emit(c, "    xor rdx,rdx\n    idiv rbx\n    mov rax,rdx\n");
            else if (strcmp(n->value, ">") == 0) emit(c, "    cmp rax,rbx\n    setg al\n    movzx rax,al\n");
            else if (strcmp(n->value, "<") == 0) emit(c, "    cmp rax,rbx\n    setl al\n    movzx rax,al\n");
            else if (strcmp(n->value, ">=") == 0) emit(c, "    cmp rax,rbx\n    setge al\n    movzx rax,al\n");
            else if (strcmp(n->value, "<=") == 0) emit(c, "    cmp rax,rbx\n    setle al\n    movzx rax,al\n");
            else if (strcmp(n->value, "==") == 0) emit(c, "    cmp rax,rbx\n    sete al\n    movzx rax,al\n");
            else if (strcmp(n->value, "!=") == 0) emit(c, "    cmp rax,rbx\n    setne al\n    movzx rax,al\n");
            else if (strcmp(n->value, "&&") == 0) emit(c, "    and rax,rbx\n");
            else if (strcmp(n->value, "||") == 0) emit(c, "    or rax,rbx\n");
        }
        else if (c->mc) {
            compile_expr(c, n->left);
            encode_push_rax(c->mc);
            compile_expr(c, n->right);
            encode_mov_rbx_rax(c->mc);
            encode_pop_rax(c->mc);
            
            if (!n->value) return;
            if (strcmp(n->value, "+") == 0) encode_add_rax_rbx(c->mc);
            else if (strcmp(n->value, "-") == 0) encode_sub_rax_rbx(c->mc);
            else if (strcmp(n->value, "*") == 0) encode_mul_rbx(c->mc);
            else if (strcmp(n->value, "/") == 0) encode_div_rbx(c->mc);
            else if (strcmp(n->value, "&&") == 0) encode_and_rax_rbx(c->mc);
            else if (strcmp(n->value, "||") == 0) encode_or_rax_rbx(c->mc);
            else if (strcmp(n->value, ">") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_setg_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (strcmp(n->value, "<") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_setl_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (strcmp(n->value, ">=") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_setge_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (strcmp(n->value, "<=") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_setle_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (strcmp(n->value, "==") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_sete_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (strcmp(n->value, "!=") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_setne_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
        }
    }
    else if (n->type == UNARY_OP_NODE) {
        ASTNode* op = n->right ? n->right : n->left;
        if (c->mode == OUT_C) {
            if (n->value && (strcmp(n->value,"!")==0 || strcmp(n->value,"no")==0)) emit(c, "!");
            else if (n->value && strcmp(n->value,"-")==0) emit(c, "-");
            compile_expr(c, op);
        }
        else if (c->mode == OUT_ASM) {
            compile_expr(c, op);
            if (n->value && (strcmp(n->value,"!")==0 || strcmp(n->value,"no")==0))
                emit(c, "    cmp rax,0\n    sete al\n    movzx rax,al\n");
            else if (n->value && strcmp(n->value,"-")==0)
                emit(c, "    neg rax\n");
        }
        else if (c->mc) {
            compile_expr(c, op);
            if (n->value && (strcmp(n->value,"!")==0 || strcmp(n->value,"no")==0)) {
                encode_cmp_rax_zero(c->mc);
                encode_sete_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (n->value && strcmp(n->value,"-")==0) {
                encode_neg_rax(c->mc);
            }
        }
    }
    else if (n->type == FN_CALL_NODE) {
        // Function call in expression - emit call and return value is in rax
        const char* fn = n->value;
        if (c->mode == OUT_C) {
            // Built-in functions
            if (strcmp(fn, "len") == 0 || strcmp(fn, "largo") == 0) {
                // String length function
                emit(c, "(int)strlen(");
                if (n->left) compile_expr(c, n->left);
                emit(c, ")");
            }
            else {
                // User-defined function call
                emit(c, "%s(", fn);
                ASTNode* arg = n->left;
                int first = 1;
                while (arg) {
                    if (!first) emit(c, ", ");
                    compile_expr(c, arg);
                    first = 0;
                    arg = arg->right;
                }
                emit(c, ")");
            }
        }
        else if (c->mode == OUT_ASM) {
            // For user-defined functions, call them - return value will be in rax
            emit(c, "    call %s\n", fn);
        }
        else if (c->mc) {
            // TODO: implement machine code call for expressions
        }
    }
}
// === FUNCTION CALL ===
static void compile_call(Compiler* c, ASTNode* n) {
    if (!n || !n->value) return;
    const char* fn = n->value;
    
    if (c->mode == OUT_C) {
        indent(c);
        if (strcmp(fn,"println")==0 || strcmp(fn,"print")==0) {
            int ln = (strcmp(fn,"println")==0);
            if (n->left && n->left->type == NUMBER_NODE)
                emit(c, "prt%snum(%s);\n", ln?"ln":"", n->left->value);
            else if (n->left && (n->left->type == STRING_LITERAL_NODE || 
                     (n->left->type == IDENTIFIER_NODE && n->left->value[0]=='"')))
                emit(c, "prt%s(%s);\n", ln?"ln":"", n->left->value);
            else if (n->left && n->left->type == IDENTIFIER_NODE) {
                if (is_var_str(c, n->left->value))
                    emit(c, "prt%s(%s);\n", ln?"ln":"", n->left->value);
                else
                    emit(c, "prt%snum(%s);\n", ln?"ln":"", n->left->value);
            }
            else if (n->left && n->left->type == BINARY_OP_NODE) {
                emit(c, "prt%snum(", ln?"ln":"");
                compile_expr(c, n->left);
                emit(c, ");\n");
            }
            else if (n->left && n->left->type == ARRAY_ACCESS_NODE) {
                // Array access returns a number
                emit(c, "prt%snum(", ln?"ln":"");
                compile_expr(c, n->left);
                emit(c, ");\n");
            }
            else if (n->left && n->left->type == FN_CALL_NODE) {
                // Function call returns a number
                emit(c, "prt%snum(", ln?"ln":"");
                compile_expr(c, n->left);
                emit(c, ");\n");
            }
            else emit(c, "prt%s(\"\");\n", ln?"ln":"");
        }
        else if (strstr(fn,"bolivar")) emit(c, "bolivar();\n");
        else if (strstr(fn,"narino")) emit(c, "narino();\n");
        else if (strstr(fn,"cano")) emit(c, "cano();\n");
        else if (strstr(fn,"gaitan")) emit(c, "gaitan();\n");
        else if (strstr(fn,"garcia")) emit(c, "garcia();\n");
        else {
            // User-defined function call with arguments
            emit(c, "%s(", fn);
            ASTNode* arg = n->left;
            int first = 1;
            while (arg) {
                if (!first) emit(c, ", ");
                compile_expr(c, arg);
                first = 0;
                arg = arg->right;
            }
            emit(c, ");\n");
        }
    }
    else if (c->mode == OUT_ASM) {
        emit(c, "    ; call %s\n", fn);
        if (strcmp(fn,"println")==0 || strcmp(fn,"print")==0) {
            if (n->left && n->left->type == NUMBER_NODE) {
                emit(c, "    mov rdi, fmt_d\n    mov rsi, %s\n", n->left->value);
            } else if (n->left && n->left->type == BINARY_OP_NODE) {
                compile_expr(c, n->left);
                emit(c, "    mov rsi, rax\n    mov rdi, fmt_d\n");
            } else if (n->left && n->left->type == IDENTIFIER_NODE && !is_var_str(c, n->left->value)) {
                int off = get_var_off(c, n->left->value);
                emit(c, "    mov rsi, [rbp%+d]\n    mov rdi, fmt_d\n", off);
            } else if (n->left) {
                char* l = add_str(c, n->left->value);
                emit(c, "    mov rdi, fmt_s\n    lea rsi, [%s]\n", l);
            }
            emit(c, "    xor rax,rax\n    call printf\n");
        }
        else {
            emit(c, "    call %s\n", fn);
        }
    }
    else if (c->mc) {
        if (strcmp(fn,"println")==0 || strcmp(fn,"print")==0) {
            if (n->left && n->left->type == NUMBER_NODE) {
                encode_mov_rdi_imm64(c->mc, 0);  // fmt placeholder
                encode_mov_rax_imm32(c->mc, atoi(n->left->value));
                encode_mov_rsi_rax(c->mc);
            } else if (n->left && n->left->type == BINARY_OP_NODE) {
                compile_expr(c, n->left);
                encode_mov_rsi_rax(c->mc);
                encode_mov_rdi_imm64(c->mc, 0);
            } else if (n->left && n->left->type == IDENTIFIER_NODE) {
                int off = get_var_off(c, n->left->value);
                encode_mov_rax_from_memory(c->mc, off);
                encode_mov_rsi_rax(c->mc);
                encode_mov_rdi_imm64(c->mc, 0);
            }
            encode_xor_rax_rax(c->mc);
            add_relocation_entry(c->mc, 1, R_X86_64_PLT32, -4);
            encode_call_rel32(c->mc, 0);
        } else {
            encode_call_external(c->mc);
        }
    }
}

// === VARIABLE DECLARATION ===
static void compile_var(Compiler* c, ASTNode* n, int spanish) {
    if (!n || !n->value) return;
    int is_str = 0;
    
    if (c->mode == OUT_C) {
        indent(c);
        if (n->left && (n->left->type == STRING_LITERAL_NODE ||
            (n->left->type == IDENTIFIER_NODE && n->left->value[0]=='"'))) {
            emit(c, "char* %s = %s;\n", n->value, n->left->value);
            is_str = 1;
        } else if (n->left) {
            emit(c, "int %s = ", n->value);
            compile_expr(c, n->left);
            emit(c, ";\n");
        } else {
            emit(c, "int %s = 0;\n", n->value);
        }
    }
    else if (c->mode == OUT_ASM) {
        int off = c->stack_off - 8;
        emit(c, "    ; var %s\n", n->value);
        if (n->left) {
            if (n->left->type == STRING_LITERAL_NODE ||
                (n->left->type == IDENTIFIER_NODE && n->left->value[0]=='"')) {
                char* l = add_str(c, n->left->value);
                emit(c, "    lea rax, [%s]\n", l);
                is_str = 1;
            } else {
                compile_expr(c, n->left);
            }
            emit(c, "    mov [rbp%+d], rax\n", off);
        } else {
            emit(c, "    mov qword [rbp%+d], 0\n", off);
        }
    }
    else if (c->mc) {
        int off = c->stack_off - 8;
        if (n->left) {
            if (n->left->type == STRING_LITERAL_NODE ||
                (n->left->type == IDENTIFIER_NODE && n->left->value[0]=='"')) {
                char* l = add_str(c, n->left->value);
                int str_off = get_str_offset(c, l);
                encode_lea_rax_rip_rel(c->mc, str_off);
                is_str = 1;
            } else {
                compile_expr(c, n->left);
            }
            encode_mov_memory_from_rax(c->mc, off);
        } else {
            encode_mov_rax_imm32(c->mc, 0);
            encode_mov_memory_from_rax(c->mc, off);
        }
    }
    add_var(c, n->value, is_str);
}

// === ASSIGNMENT ===
static void compile_assign(Compiler* c, ASTNode* n) {
    if (!n || !n->value) return;

    // Check for array assignment: arr[index] = value
    // In this case, n->left is ARRAY_ACCESS_NODE and n->extra is the value
    if (n->left && n->left->type == ARRAY_ACCESS_NODE && n->extra) {
        if (c->mode == OUT_C) {
            indent(c);
            emit(c, "%s[", n->value);
            compile_expr(c, n->left->left);  // index
            emit(c, "] = ");
            compile_expr(c, n->extra);  // value
            emit(c, ";\n");
        }
        else if (c->mode == OUT_ASM) {
            // TODO: implement array assignment in assembly
            emit(c, "    ; array assign %s[...] = ...\n", n->value);
        }
        else if (c->mc) {
            // TODO: implement array assignment in machine code
        }
    }
    // Simple variable assignment: var = value
    else if (n->left) {
        if (c->mode == OUT_C) {
            indent(c);
            emit(c, "%s = ", n->value);
            compile_expr(c, n->left);
            emit(c, ";\n");
        }
        else if (c->mode == OUT_ASM) {
            int off = get_var_off(c, n->value);
            compile_expr(c, n->left);
            emit(c, "    mov [rbp%+d], rax\n", off);
        }
        else if (c->mc) {
            int off = get_var_off(c, n->value);
            compile_expr(c, n->left);
            encode_mov_memory_from_rax(c->mc, off);
        }
    }
}

// === IF STATEMENT ===
static void compile_if(Compiler* c, ASTNode* n) {
    static int lbl = 0;
    int id = lbl++;

    if (c->mode == OUT_C) {
        indent(c); emit(c, "if ("); compile_expr(c, n->left); emit(c, ") {\n");
        c->indent++;
        compile_node(c, n->body);
        c->indent--;
        indent(c); emit(c, "}");
        if (n->extra) {
            emit(c, " else {\n");
            c->indent++;
            compile_node(c, n->extra);
            c->indent--;
            indent(c); emit(c, "}");
        }
        emit(c, "\n");
    }
    else if (c->mode == OUT_ASM) {
        compile_expr(c, n->left);
        emit(c, "    cmp rax, 0\n    je .Lelse%d\n", id);
        compile_node(c, n->body);
        emit(c, "    jmp .Lend%d\n.Lelse%d:\n", id, id);
        if (n->extra) compile_node(c, n->extra);
        emit(c, ".Lend%d:\n", id);
    }
    else if (c->mc) {
        compile_expr(c, n->left);
        encode_cmp_rax_zero(c->mc);

        int je_pos = c->mc->size;
        encode_je_rel32(c->mc, 0);  // placeholder

        compile_node(c, n->body);

        int jmp_pos = c->mc->size;
        encode_jmp_rel32(c->mc, 0);  // placeholder

        int else_pos = c->mc->size;
        patch_jump_offset(c->mc, je_pos + 2, else_pos);

        if (n->extra) compile_node(c, n->extra);

        int end_pos = c->mc->size;
        patch_jump_offset(c->mc, jmp_pos + 1, end_pos);
    }
}

// === WHILE LOOP ===
static void compile_while(Compiler* c, ASTNode* n) {
    static int lbl = 0;
    int id = lbl++;

    if (c->mode == OUT_C) {
        indent(c); emit(c, "while ("); compile_expr(c, n->left); emit(c, ") {\n");
        c->indent++;
        compile_node(c, n->body);
        c->indent--;
        indent(c); emit(c, "}\n");
    }
    else if (c->mode == OUT_ASM) {
        emit(c, ".Lw%d:\n", id);
        compile_expr(c, n->left);
        emit(c, "    cmp rax,0\n    je .Lwe%d\n", id);
        compile_node(c, n->body);
        emit(c, "    jmp .Lw%d\n.Lwe%d:\n", id, id);
    }
    else if (c->mc) {
        int start_pos = c->mc->size;

        compile_expr(c, n->left);
        encode_cmp_rax_zero(c->mc);

        int je_pos = c->mc->size;
        encode_je_rel32(c->mc, 0);  // placeholder

        compile_node(c, n->body);

        int jmp_pos = c->mc->size;
        encode_jmp_rel32(c->mc, 0);  // placeholder
        patch_jump_offset(c->mc, jmp_pos + 1, start_pos);

        int end_pos = c->mc->size;
        patch_jump_offset(c->mc, je_pos + 2, end_pos);
    }
}

// === FOR LOOP ===
static void compile_for(Compiler* c, ASTNode* n) {
    static int lbl = 0;
    int id = lbl++;

    if (c->mode == OUT_C) {
        indent(c); emit(c, "for (");
        if (n->left) {
            if (n->left->type == VAR_DECL_NODE || n->left->type == VAR_DECL_SPANISH_NODE) {
                // Variable declaration in for loop init: int i = value
                emit(c, "int %s = ", n->left->value);
                if (n->left->left) compile_expr(c, n->left->left);
                else emit(c, "0");
            } else if (n->left->type == ASSIGN_NODE) {
                // Assignment in for loop init: i = value
                emit(c, "%s = ", n->left->value ? n->left->value : "");
                if (n->left->right) compile_expr(c, n->left->right);
            } else {
                compile_expr(c, n->left);
            }
        }
        emit(c, "; ");
        if (n->extra && n->extra->left) compile_expr(c, n->extra->left);
        emit(c, "; ");
        if (n->extra && n->extra->right) {
            if (n->extra->right->type == ASSIGN_NODE) {
                // Assignment in for loop increment: i = i + 1
                emit(c, "%s = ", n->extra->right->value ? n->extra->right->value : "");
                if (n->extra->right->right) compile_expr(c, n->extra->right->right);
            } else {
                compile_expr(c, n->extra->right);
            }
        }
        emit(c, ") {\n");
        c->indent++;
        compile_node(c, n->body);
        c->indent--;
        indent(c); emit(c, "}\n");
    }
    else if (c->mode == OUT_ASM) {
        if (n->left) compile_node(c, n->left);
        emit(c, ".Lf%d:\n", id);
        if (n->extra && n->extra->left) {
            compile_expr(c, n->extra->left);
            emit(c, "    cmp rax,0\n    je .Lfe%d\n", id);
        }
        compile_node(c, n->body);
        if (n->extra && n->extra->right) compile_node(c, n->extra->right);
        emit(c, "    jmp .Lf%d\n.Lfe%d:\n", id, id);
    }
    else if (c->mc) {
        if (n->left) compile_node(c, n->left);

        int start_pos = c->mc->size;

        int je_pos = -1;
        if (n->extra && n->extra->left) {
            compile_expr(c, n->extra->left);
            encode_cmp_rax_zero(c->mc);
            je_pos = c->mc->size;
            encode_je_rel32(c->mc, 0);
        }

        compile_node(c, n->body);

        if (n->extra && n->extra->right) compile_node(c, n->extra->right);

        int jmp_pos = c->mc->size;
        encode_jmp_rel32(c->mc, 0);
        patch_jump_offset(c->mc, jmp_pos + 1, start_pos);

        if (je_pos >= 0) {
            int end_pos = c->mc->size;
            patch_jump_offset(c->mc, je_pos + 2, end_pos);
        }
    }
}

// === RETURN ===
static void compile_return(Compiler* c, ASTNode* n) {
    if (c->mode == OUT_C) {
        indent(c); emit(c, "return ");
        if (n->left) compile_expr(c, n->left);
        else emit(c, "0");
        emit(c, ";\n");
    }
    else if (c->mode == OUT_ASM) {
        if (n->left) compile_expr(c, n->left);
        else emit(c, "    xor rax,rax\n");
        emit(c, "    leave\n    ret\n");
    }
    else if (c->mc) {
        if (n->left) compile_expr(c, n->left);
        else encode_xor_rax_rax(c->mc);
        encode_leave(c->mc);
        encode_ret(c->mc);
    }
}

// === FUNCTION DECLARATION ===
static void compile_func(Compiler* c, ASTNode* n) {
    const char* name = n->value ? n->value : "func";

    if (c->mode == OUT_C) {
        // Emit function signature with parameters
        emit(c, "int %s(", name);

        // Parameters are stored in n->left as a linked list
        ASTNode* param = n->left;
        int first = 1;
        while (param) {
            if (!first) emit(c, ", ");
            emit(c, "int %s", param->value ? param->value : "arg");
            first = 0;
            param = param->right;
        }
        emit(c, ") {\n");
        c->indent++;
        compile_node(c, n->body);
        c->indent--;
        emit(c, "    return 0;\n}\n\n");
    }
    else if (c->mode == OUT_ASM) {
        emit(c, "%s:\n    push rbp\n    mov rbp,rsp\n    sub rsp,256\n", name);
        compile_node(c, n->body);
        emit(c, "    xor rax,rax\n    leave\n    ret\n\n");
    }
    else if (c->mc) {
        encode_push_rbp(c->mc);
        encode_mov_rbp_rsp(c->mc);
        encode_sub_rsp_imm8(c->mc, 128);
        compile_node(c, n->body);
        encode_xor_rax_rax(c->mc);
        encode_leave(c->mc);
        encode_ret(c->mc);
    }
}

// === FUNCTION DECLARATION PASS (for C output - hoists functions outside main) ===
static void compile_functions_pass(Compiler* c, ASTNode* n) {
    while (n) {
        if (n->type == PROGRAM_NODE) {
            compile_functions_pass(c, n->left);
        } else if (n->type == FN_DECL_NODE || n->type == FN_DECL_SPANISH_NODE) {
            compile_func(c, n);
        }
        n = n->right;
    }
}

// === NODE DISPATCHER ===
// skip_funcs: if true, skip function declarations (they're hoisted in C mode)
static void compile_node_ex(Compiler* c, ASTNode* n, int skip_funcs) {
    while (n) {
        switch (n->type) {
            case PROGRAM_NODE: compile_node_ex(c, n->left, skip_funcs); break;
            case FN_CALL_NODE: compile_call(c, n); break;
            case FN_DECL_NODE: case FN_DECL_SPANISH_NODE:
                if (!skip_funcs) compile_func(c, n);
                break;
            case VAR_DECL_NODE: compile_var(c, n, 0); break;
            case VAR_DECL_SPANISH_NODE: compile_var(c, n, 1); break;
            case ARRAY_DECL_NODE:
                // Array declaration: int arr[size];
                if (c->mode == OUT_C) {
                    indent(c);
                    emit(c, "int %s[", n->value);
                    if (n->left) compile_expr(c, n->left);
                    emit(c, "];\n");
                }
                break;
            case ASSIGN_NODE: compile_assign(c, n); break;
            case IF_NODE: case IF_SPANISH_NODE: compile_if(c, n); break;
            case WHILE_NODE: case WHILE_SPANISH_NODE: compile_while(c, n); break;
            case FOR_NODE: case FOR_SPANISH_NODE: compile_for(c, n); break;
            case RETURN_NODE: compile_return(c, n); break;
            case BREAK_NODE:
                if (c->mode == OUT_C) { indent(c); emit(c, "break;\n"); }
                break;
            case CONTINUE_NODE:
                if (c->mode == OUT_C) { indent(c); emit(c, "continue;\n"); }
                break;
            default: break;
        }
        n = n->right;
    }
}

static void compile_node(Compiler* c, ASTNode* n) {
    compile_node_ex(c, n, 0);
}

// === MAIN WRAPPER ===
static void compile_main(Compiler* c, ASTNode* ast) {
    if (c->mode == OUT_C) {
        // For C output: first emit function definitions BEFORE main()
        compile_functions_pass(c, ast);
        emit(c, "int main() {\n");
        c->indent = 1;
    } else if (c->mode == OUT_ASM) {
        // Strings written later
    } else if (c->mc) {
        encode_push_rbp(c->mc);
        encode_mov_rbp_rsp(c->mc);
        encode_sub_rsp_imm8(c->mc, 128);
    }

    // For C mode, skip function declarations (already hoisted)
    // For other modes, compile everything
    compile_node_ex(c, ast, c->mode == OUT_C ? 1 : 0);
    
    if (c->mode == OUT_C) {
        emit(c, "    return 0;\n}\n");
    } else if (c->mode == OUT_ASM) {
        emit(c, "main:\n    push rbp\n    mov rbp,rsp\n    sub rsp,256\n");
        // Code already in buffer, append ending
        emit(c, "    xor rax,rax\n    leave\n    ret\n");
    } else if (c->mc) {
        encode_xor_rax_rax(c->mc);
        encode_leave(c->mc);
        encode_ret(c->mc);
    }
}

// === PUBLIC API ===
int compile_viva_to_c(const char* code, const char* outfile) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_C);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}

int compile_viva_to_asm(const char* code, const char* outfile) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_ASM);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}

int compile_viva_to_elf(const char* code, const char* outfile) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_ELF);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    c->plat = PLATFORM_LINUX;
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}

int compile_viva_to_platform(const char* code, const char* outfile, PlatformTarget plat) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_ELF);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    c->plat = plat;
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}
