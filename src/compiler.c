// src/compiler.c - EXPANDED for Phase 4
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <stdint.h>
#include "../include/lexer.h"
#include "../include/parser.h"
#include "../include/compiler.h"
#include "../include/machine_code.h"
#include "../include/macho.h"
#include "../include/pe_coff.h"

#define MAX_VARS 100
#define MAX_STRS 100
#define MAX_BUF 16384
#define MAX_LABELS 256

typedef enum { OUT_C, OUT_ASM, OUT_ELF, OUT_STANDALONE } OutMode;

typedef struct { char name[64]; int is_str; int offset; } Var;
typedef struct { char val[256]; char lbl[32]; int offset; } Str;
typedef struct { char name[32]; int offset; } Label;

typedef struct {
    FILE* f;
    OutMode mode;
    PlatformTarget plat;
    int indent;
    Var vars[MAX_VARS];
    int nvar;
    Str strs[MAX_STRS];
    int nstr;
    Label labels[MAX_LABELS];
    int nlbl;
    char buf[MAX_BUF];
    int bufpos;
    char outname[256];
    MachineCode* mc;
    ELFFile* elf;
    int stack_off;
    int data_size;
} Compiler;

// Forward declarations
static void compile_node(Compiler* c, ASTNode* n);
static void compile_expr(Compiler* c, ASTNode* n);

// === EMIT HELPERS ===
static void emit(Compiler* c, const char* fmt, ...) {
    va_list a;
    va_start(a, fmt);
    if (c->mode == OUT_ASM) {
        int r = MAX_BUF - c->bufpos;
        int n = vsnprintf(c->buf + c->bufpos, r, fmt, a);
        if (n > 0 && n < r) c->bufpos += n;
    } else if (c->mode == OUT_C) {
        vfprintf(c->f, fmt, a);
    }
    va_end(a);
}

static void indent(Compiler* c) {
    for (int i = 0; i < c->indent; i++) emit(c, "    ");
}

// === VARIABLE MANAGEMENT ===
static int find_var(Compiler* c, const char* name) {
    for (int i = 0; i < c->nvar; i++)
        if (strcmp(c->vars[i].name, name) == 0) return i;
    return -1;
}

static int add_var(Compiler* c, const char* name, int is_str) {
    if (c->nvar >= MAX_VARS) return -1;
    strncpy(c->vars[c->nvar].name, name, 63);
    c->vars[c->nvar].is_str = is_str;
    c->stack_off -= 8;
    c->vars[c->nvar].offset = c->stack_off;
    return c->nvar++;
}

static int get_var_off(Compiler* c, const char* name) {
    int i = find_var(c, name);
    return (i >= 0) ? c->vars[i].offset : -8;
}

static int is_var_str(Compiler* c, const char* name) {
    int i = find_var(c, name);
    return (i >= 0) ? c->vars[i].is_str : 0;
}

// === STRING MANAGEMENT ===
static char* add_str(Compiler* c, const char* s) {
    if (c->nstr >= MAX_STRS) return "str_err";
    static int cnt = 0;
    snprintf(c->strs[c->nstr].lbl, 32, "str_%d", cnt++);
    
    const char* p = (s[0] == '"') ? s + 1 : s;
    strncpy(c->strs[c->nstr].val, p, 255);
    size_t len = strlen(c->strs[c->nstr].val);
    if (len > 0 && c->strs[c->nstr].val[len-1] == '"')
        c->strs[c->nstr].val[len-1] = '\0';
    
    c->strs[c->nstr].offset = c->data_size;
    c->data_size += strlen(c->strs[c->nstr].val) + 1;
    
    return c->strs[c->nstr++].lbl;
}

static int get_str_offset(Compiler* c, const char* lbl) {
    for (int i = 0; i < c->nstr; i++)
        if (strcmp(c->strs[i].lbl, lbl) == 0) return c->strs[i].offset;
    return 0;
}

// === COMPILER INIT/FINISH ===
static Compiler* init_compiler(const char* outfile, OutMode mode) {
    Compiler* c = calloc(1, sizeof(Compiler));
    if (!c) return NULL;
    c->mode = mode;
    c->plat = PLATFORM_LINUX;
    strncpy(c->outname, outfile, 255);
    
    if (mode == OUT_ELF || mode == OUT_STANDALONE) {
        c->mc = init_machine_code();
        if (mode == OUT_ELF) {
            c->elf = init_elf_file();
        }
    }
    
    c->f = fopen(outfile, "wb");
    if (!c->f) { free(c); return NULL; }
    
    if (mode == OUT_C) {
        fprintf(c->f,
            "// Generated by Viva Colombia compiler\n"
            "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n"
            "void prt(char* s){printf(\"%%s\",s);}\n"
            "void prtln(char* s){printf(\"%%s\\n\",s);}\n"
            "void prtnum(int n){printf(\"%%d\",n);}\n"
            "void prtlnnum(int n){printf(\"%%d\\n\",n);}\n"
            "void bolivar(){printf(\"Simon Bolivar: Libertador\\n\");}\n"
            "void narino(){printf(\"Francisco Narino: Heroe\\n\");}\n"
            "void cano(){printf(\"Maria Cano: Lider\\n\");}\n"
            "void gaitan(){printf(\"Jorge Gaitan: Lider politico\\n\");}\n"
            "void garcia(){printf(\"Gabriel Garcia Marquez: Nobel\\n\");}\n\n");
    } else if (mode == OUT_ASM) {
        fprintf(c->f,
            "; Generated by Viva Colombia\n"
            "section .data\n"
            "    fmt_s db \"%%s\",10,0\n"
            "    fmt_d db \"%%d\",10,0\n");
    }
    return c;
}

static void write_asm_strings(Compiler* c) {
    if (c->mode != OUT_ASM) return;
    for (int i = 0; i < c->nstr; i++) {
        fprintf(c->f, "    %s db \"%s\",0\n", c->strs[i].lbl, c->strs[i].val);
    }
    fprintf(c->f,
        "section .text\n"
        "    global main\n"
        "    extern printf\n\n");
}

static void write_elf_data_section(Compiler* c) {
    if (c->mode != OUT_ELF || c->nstr == 0) return;
    
    uint8_t* data = calloc(1, c->data_size + 1);
    if (!data) return;
    
    int off = 0;
    for (int i = 0; i < c->nstr; i++) {
        size_t len = strlen(c->strs[i].val);
        memcpy(data + off, c->strs[i].val, len);
        data[off + len] = 0;
        off += len + 1;
    }
    
    create_data_section(c->elf, data, c->data_size);
    free(data);
}

static void finish_compiler(Compiler* c) {
    if (!c) return;

    if (c->mode == OUT_ASM) {
        write_asm_strings(c);
        if (c->bufpos > 0)
            fwrite(c->buf, 1, c->bufpos, c->f);
    }

    if (c->mode == OUT_ELF && c->elf && c->mc) {
        write_elf_data_section(c);
        create_text_section(c->elf, c->mc);
        create_symbol_table(c->elf);
        fclose(c->f);
        c->f = NULL;
        write_complete_elf_file(c->elf, c->outname);
    }

    if (c->mode == OUT_STANDALONE && c->mc) {
        // Build data section for strings
        uint8_t* data = NULL;
        size_t data_size = 0;
        if (c->nstr > 0) {
            data_size = c->data_size;
            data = calloc(1, data_size + 1);
            if (data) {
                int off = 0;
                for (int i = 0; i < c->nstr; i++) {
                    size_t len = strlen(c->strs[i].val);
                    memcpy(data + off, c->strs[i].val, len);
                    data[off + len] = '\n';  // Add newline for syscall output
                    off += len + 1;
                }
            }
        }
        fclose(c->f);
        c->f = NULL;

        // Use platform-aware standalone writer
        switch (c->plat) {
            case PLATFORM_LINUX:
                write_standalone_elf_executable(c->outname, c->mc, data, data_size);
                break;
            case PLATFORM_FREEBSD:
                write_standalone_freebsd_executable(c->outname, c->mc, data, data_size);
                break;
            case PLATFORM_MACOS:
                write_standalone_macho_executable(c->outname, c->mc, data, data_size);
                break;
            case PLATFORM_WINDOWS:
                write_standalone_pe_executable(c->outname, c->mc, data, data_size);
                break;
        }
        if (data) free(data);
    }

    if (c->f) fclose(c->f);
    if (c->mc) free_machine_code(c->mc);
    if (c->elf) free_elf_file(c->elf);
    free(c);
}

// === EXPRESSION COMPILATION ===
static void compile_expr(Compiler* c, ASTNode* n) {
    if (!n) return;
    
    if (n->type == NUMBER_NODE) {
        if (c->mode == OUT_C) emit(c, "%s", n->value);
        else if (c->mode == OUT_ASM) emit(c, "    mov rax, %s\n", n->value);
        else if (c->mc) encode_mov_rax_imm32(c->mc, atoi(n->value));
    }
    else if (n->type == STRING_LITERAL_NODE) {
        if (c->mode == OUT_C) emit(c, "%s", n->value);
        else if (c->mode == OUT_ASM) {
            char* l = add_str(c, n->value);
            emit(c, "    lea rax, [%s]\n", l);
        }
        else if (c->mc) {
            char* l = add_str(c, n->value);
            int off = get_str_offset(c, l);
            encode_lea_rax_rip_rel(c->mc, off);
        }
    }
    else if (n->type == IDENTIFIER_NODE) {
        if (n->value && n->value[0] == '"') {
            if (c->mode == OUT_C) emit(c, "%s", n->value);
            else if (c->mode == OUT_ASM) {
                char* l = add_str(c, n->value);
                emit(c, "    lea rax, [%s]\n", l);
            }
            else if (c->mc) {
                char* l = add_str(c, n->value);
                int off = get_str_offset(c, l);
                encode_lea_rax_rip_rel(c->mc, off);
            }
        } else {
            if (c->mode == OUT_C) emit(c, "%s", n->value);
            else if (c->mode == OUT_ASM) {
                int off = get_var_off(c, n->value);
                emit(c, "    mov rax, [rbp%+d]\n", off);
            }
            else if (c->mc) {
                int off = get_var_off(c, n->value);
                encode_mov_rax_from_memory(c->mc, off);
            }
        }
    }
    else if (n->type == BINARY_OP_NODE) {
        if (c->mode == OUT_C) {
            emit(c, "(");
            compile_expr(c, n->left);
            emit(c, " %s ", n->value ? n->value : "+");
            compile_expr(c, n->right);
            emit(c, ")");
        }
        else if (c->mode == OUT_ASM) {
            compile_expr(c, n->left);
            emit(c, "    push rax\n");
            compile_expr(c, n->right);
            emit(c, "    mov rbx, rax\n    pop rax\n");
            
            if (!n->value) return;
            if (strcmp(n->value, "+") == 0) emit(c, "    add rax, rbx\n");
            else if (strcmp(n->value, "-") == 0) emit(c, "    sub rax, rbx\n");
            else if (strcmp(n->value, "*") == 0) emit(c, "    imul rax, rbx\n");
            else if (strcmp(n->value, "/") == 0) emit(c, "    xor rdx,rdx\n    idiv rbx\n");
            else if (strcmp(n->value, "%") == 0) emit(c, "    xor rdx,rdx\n    idiv rbx\n    mov rax,rdx\n");
            else if (strcmp(n->value, ">") == 0) emit(c, "    cmp rax,rbx\n    setg al\n    movzx rax,al\n");
            else if (strcmp(n->value, "<") == 0) emit(c, "    cmp rax,rbx\n    setl al\n    movzx rax,al\n");
            else if (strcmp(n->value, ">=") == 0) emit(c, "    cmp rax,rbx\n    setge al\n    movzx rax,al\n");
            else if (strcmp(n->value, "<=") == 0) emit(c, "    cmp rax,rbx\n    setle al\n    movzx rax,al\n");
            else if (strcmp(n->value, "==") == 0) emit(c, "    cmp rax,rbx\n    sete al\n    movzx rax,al\n");
            else if (strcmp(n->value, "!=") == 0) emit(c, "    cmp rax,rbx\n    setne al\n    movzx rax,al\n");
            else if (strcmp(n->value, "&&") == 0) emit(c, "    and rax,rbx\n");
            else if (strcmp(n->value, "||") == 0) emit(c, "    or rax,rbx\n");
        }
        else if (c->mc) {
            compile_expr(c, n->left);
            encode_push_rax(c->mc);
            compile_expr(c, n->right);
            encode_mov_rbx_rax(c->mc);
            encode_pop_rax(c->mc);
            
            if (!n->value) return;
            if (strcmp(n->value, "+") == 0) encode_add_rax_rbx(c->mc);
            else if (strcmp(n->value, "-") == 0) encode_sub_rax_rbx(c->mc);
            else if (strcmp(n->value, "*") == 0) encode_mul_rbx(c->mc);
            else if (strcmp(n->value, "/") == 0) encode_div_rbx(c->mc);
            else if (strcmp(n->value, "&&") == 0) encode_and_rax_rbx(c->mc);
            else if (strcmp(n->value, "||") == 0) encode_or_rax_rbx(c->mc);
            else if (strcmp(n->value, ">") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_setg_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (strcmp(n->value, "<") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_setl_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (strcmp(n->value, ">=") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_setge_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (strcmp(n->value, "<=") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_setle_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (strcmp(n->value, "==") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_sete_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (strcmp(n->value, "!=") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_setne_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
        }
    }
    else if (n->type == UNARY_OP_NODE) {
        ASTNode* op = n->right ? n->right : n->left;
        if (c->mode == OUT_C) {
            if (n->value && (strcmp(n->value,"!")==0 || strcmp(n->value,"no")==0)) emit(c, "!");
            else if (n->value && strcmp(n->value,"-")==0) emit(c, "-");
            compile_expr(c, op);
        }
        else if (c->mode == OUT_ASM) {
            compile_expr(c, op);
            if (n->value && (strcmp(n->value,"!")==0 || strcmp(n->value,"no")==0))
                emit(c, "    cmp rax,0\n    sete al\n    movzx rax,al\n");
            else if (n->value && strcmp(n->value,"-")==0)
                emit(c, "    neg rax\n");
        }
        else if (c->mc) {
            compile_expr(c, op);
            if (n->value && (strcmp(n->value,"!")==0 || strcmp(n->value,"no")==0)) {
                encode_cmp_rax_zero(c->mc);
                encode_sete_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (n->value && strcmp(n->value,"-")==0) {
                encode_neg_rax(c->mc);
            }
        }
    }
}
// === FUNCTION CALL ===
static void compile_call(Compiler* c, ASTNode* n) {
    if (!n || !n->value) return;
    const char* fn = n->value;
    
    if (c->mode == OUT_C) {
        indent(c);
        if (strcmp(fn,"println")==0 || strcmp(fn,"print")==0) {
            int ln = (strcmp(fn,"println")==0);
            if (n->left && n->left->type == NUMBER_NODE)
                emit(c, "prt%snum(%s);\n", ln?"ln":"", n->left->value);
            else if (n->left && (n->left->type == STRING_LITERAL_NODE || 
                     (n->left->type == IDENTIFIER_NODE && n->left->value[0]=='"')))
                emit(c, "prt%s(%s);\n", ln?"ln":"", n->left->value);
            else if (n->left && n->left->type == IDENTIFIER_NODE) {
                if (is_var_str(c, n->left->value))
                    emit(c, "prt%s(%s);\n", ln?"ln":"", n->left->value);
                else
                    emit(c, "prt%snum(%s);\n", ln?"ln":"", n->left->value);
            }
            else if (n->left && n->left->type == BINARY_OP_NODE) {
                emit(c, "prt%snum(", ln?"ln":"");
                compile_expr(c, n->left);
                emit(c, ");\n");
            }
            else emit(c, "prt%s(\"\");\n", ln?"ln":"");
        }
        else if (strstr(fn,"bolivar")) emit(c, "bolivar();\n");
        else if (strstr(fn,"narino")) emit(c, "narino();\n");
        else if (strstr(fn,"cano")) emit(c, "cano();\n");
        else if (strstr(fn,"gaitan")) emit(c, "gaitan();\n");
        else if (strstr(fn,"garcia")) emit(c, "garcia();\n");
        else emit(c, "%s();\n", fn);
    }
    else if (c->mode == OUT_ASM) {
        emit(c, "    ; call %s\n", fn);
        if (strcmp(fn,"println")==0 || strcmp(fn,"print")==0) {
            if (n->left && n->left->type == NUMBER_NODE) {
                emit(c, "    mov rsi, %s\n", n->left->value);
                emit(c, "    mov rdi, fmt_d\n");
            } else if (n->left && n->left->type == BINARY_OP_NODE) {
                compile_expr(c, n->left);
                emit(c, "    mov rsi, rax\n");
                emit(c, "    mov rdi, fmt_d\n");
            } else if (n->left && n->left->type == STRING_LITERAL_NODE) {
                // String literal node
                char* l = add_str(c, n->left->value);
                emit(c, "    lea rsi, [%s]\n", l);
                emit(c, "    mov rdi, fmt_s\n");
            } else if (n->left && n->left->type == IDENTIFIER_NODE &&
                       n->left->value && n->left->value[0] == '"') {
                // String literal stored as identifier (quoted string)
                char* l = add_str(c, n->left->value);
                emit(c, "    lea rsi, [%s]\n", l);
                emit(c, "    mov rdi, fmt_s\n");
            } else if (n->left && n->left->type == IDENTIFIER_NODE) {
                int off = get_var_off(c, n->left->value);
                if (is_var_str(c, n->left->value)) {
                    // String variable - load pointer and use string format
                    emit(c, "    mov rsi, [rbp%+d]\n", off);
                    emit(c, "    mov rdi, fmt_s\n");
                } else {
                    // Integer variable - load value and use integer format
                    emit(c, "    mov rsi, [rbp%+d]\n", off);
                    emit(c, "    mov rdi, fmt_d\n");
                }
            } else {
                emit(c, "    mov rdi, fmt_s\n");
                emit(c, "    xor rsi, rsi\n");
            }
            emit(c, "    xor rax, rax\n");
            emit(c, "    call printf\n");
        }
        else {
            emit(c, "    call %s\n", fn);
        }
    }
    else if (c->mode == OUT_ELF && c->mc) {
        // ELF object mode - uses printf via relocation
        if (strcmp(fn,"println")==0 || strcmp(fn,"print")==0) {
            if (n->left && n->left->type == NUMBER_NODE) {
                encode_mov_rdi_imm64(c->mc, 0);  // fmt placeholder
                encode_mov_rax_imm32(c->mc, atoi(n->left->value));
                encode_mov_rsi_rax(c->mc);
            } else if (n->left && n->left->type == BINARY_OP_NODE) {
                compile_expr(c, n->left);
                encode_mov_rsi_rax(c->mc);
                encode_mov_rdi_imm64(c->mc, 0);
            } else if (n->left && n->left->type == IDENTIFIER_NODE) {
                int off = get_var_off(c, n->left->value);
                encode_mov_rax_from_memory(c->mc, off);
                encode_mov_rsi_rax(c->mc);
                encode_mov_rdi_imm64(c->mc, 0);
            }
            encode_xor_rax_rax(c->mc);
            add_relocation_entry(c->mc, 1, R_X86_64_PLT32, -4);
            encode_call_rel32(c->mc, 0);
        } else {
            encode_call_external(c->mc);
        }
    }
    else if (c->mode == OUT_STANDALONE && c->mc) {
        // Standalone mode - uses Linux syscalls directly (NO libc!)
        if (strcmp(fn,"println")==0 || strcmp(fn,"print")==0) {
            int is_println = (strcmp(fn,"println")==0);

            if (n->left && (n->left->type == STRING_LITERAL_NODE ||
                (n->left->type == IDENTIFIER_NODE && n->left->value && n->left->value[0]=='"'))) {
                // String literal - use sys_write syscall
                char* l = add_str(c, n->left->value);
                int str_off = get_str_offset(c, l);
                size_t str_len = strlen(c->strs[c->nstr-1].val);
                if (is_println) str_len++;  // Include newline

                // sys_write(fd=1, buf=str, count=len)
                encode_mov_rax_imm32(c->mc, 1);     // RAX = 1 (sys_write)
                encode_mov_rdi_rax(c->mc);          // RDI = 1 (stdout)
                encode_lea_rsi_rip_rel(c->mc, 0);   // RSI = string address (placeholder)
                add_data_relocation(c->mc, str_off);  // Record for fixup
                encode_mov_rdx_imm32(c->mc, (int32_t)str_len);  // RDX = length
                encode_syscall(c->mc);
            }
            else if (n->left && n->left->type == NUMBER_NODE) {
                // Number - need to convert to string and print
                // For now, we'll use a simple approach: just store the number as a string
                char num_str[32];
                snprintf(num_str, sizeof(num_str), "\"%s\"", n->left->value);
                char* l = add_str(c, num_str);
                int str_off = get_str_offset(c, l);
                size_t str_len = strlen(c->strs[c->nstr-1].val);
                if (is_println) str_len++;

                encode_mov_rax_imm32(c->mc, 1);
                encode_mov_rdi_rax(c->mc);
                encode_lea_rsi_rip_rel(c->mc, 0);
                add_data_relocation(c->mc, str_off);
                encode_mov_rdx_imm32(c->mc, (int32_t)str_len);
                encode_syscall(c->mc);
            }
            // Note: Variable printing not fully implemented for standalone yet
        }
    }
}

// === VARIABLE DECLARATION ===
static void compile_var(Compiler* c, ASTNode* n, int spanish) {
    if (!n || !n->value) return;
    int is_str = 0;
    
    if (c->mode == OUT_C) {
        indent(c);
        if (n->left && (n->left->type == STRING_LITERAL_NODE ||
            (n->left->type == IDENTIFIER_NODE && n->left->value[0]=='"'))) {
            emit(c, "char* %s = %s;\n", n->value, n->left->value);
            is_str = 1;
        } else if (n->left) {
            emit(c, "int %s = ", n->value);
            compile_expr(c, n->left);
            emit(c, ";\n");
        } else {
            emit(c, "int %s = 0;\n", n->value);
        }
    }
    else if (c->mode == OUT_ASM) {
        int off = c->stack_off - 8;
        emit(c, "    ; var %s\n", n->value);
        if (n->left) {
            if (n->left->type == STRING_LITERAL_NODE ||
                (n->left->type == IDENTIFIER_NODE && n->left->value[0]=='"')) {
                char* l = add_str(c, n->left->value);
                emit(c, "    lea rax, [%s]\n", l);
                is_str = 1;
            } else {
                compile_expr(c, n->left);
            }
            emit(c, "    mov [rbp%+d], rax\n", off);
        } else {
            emit(c, "    mov qword [rbp%+d], 0\n", off);
        }
    }
    else if (c->mc) {
        int off = c->stack_off - 8;
        if (n->left) {
            if (n->left->type == STRING_LITERAL_NODE ||
                (n->left->type == IDENTIFIER_NODE && n->left->value[0]=='"')) {
                char* l = add_str(c, n->left->value);
                int str_off = get_str_offset(c, l);
                encode_lea_rax_rip_rel(c->mc, str_off);
                is_str = 1;
            } else {
                compile_expr(c, n->left);
            }
            encode_mov_memory_from_rax(c->mc, off);
        } else {
            encode_mov_rax_imm32(c->mc, 0);
            encode_mov_memory_from_rax(c->mc, off);
        }
    }
    add_var(c, n->value, is_str);
}

// === ASSIGNMENT ===
static void compile_assign(Compiler* c, ASTNode* n) {
    if (!n || !n->value || !n->left) return;
    
    if (c->mode == OUT_C) {
        indent(c);
        emit(c, "%s = ", n->value);
        compile_expr(c, n->left);
        emit(c, ";\n");
    }
    else if (c->mode == OUT_ASM) {
        int off = get_var_off(c, n->value);
        compile_expr(c, n->left);
        emit(c, "    mov [rbp%+d], rax\n", off);
    }
    else if (c->mc) {
        int off = get_var_off(c, n->value);
        compile_expr(c, n->left);
        encode_mov_memory_from_rax(c->mc, off);
    }
}

// === IF STATEMENT ===
static void compile_if(Compiler* c, ASTNode* n) {
    static int lbl = 0;
    int id = lbl++;
    
    if (c->mode == OUT_C) {
        indent(c); emit(c, "if ("); compile_expr(c, n->left); emit(c, ") {\n");
        c->indent++;
        compile_node(c, n->right);
        c->indent--;
        indent(c); emit(c, "}");
        if (n->extra) {
            emit(c, " else {\n");
            c->indent++;
            compile_node(c, n->extra);
            c->indent--;
            indent(c); emit(c, "}");
        }
        emit(c, "\n");
    }
    else if (c->mode == OUT_ASM) {
        compile_expr(c, n->left);
        emit(c, "    cmp rax, 0\n    je .Lelse%d\n", id);
        compile_node(c, n->right);
        emit(c, "    jmp .Lend%d\n.Lelse%d:\n", id, id);
        if (n->extra) compile_node(c, n->extra);
        emit(c, ".Lend%d:\n", id);
    }
    else if (c->mc) {
        compile_expr(c, n->left);
        encode_cmp_rax_zero(c->mc);
        
        int je_pos = c->mc->size;
        encode_je_rel32(c->mc, 0);  // placeholder
        
        compile_node(c, n->right);
        
        int jmp_pos = c->mc->size;
        encode_jmp_rel32(c->mc, 0);  // placeholder
        
        int else_pos = c->mc->size;
        patch_jump_offset(c->mc, je_pos + 2, else_pos);
        
        if (n->extra) compile_node(c, n->extra);
        
        int end_pos = c->mc->size;
        patch_jump_offset(c->mc, jmp_pos + 1, end_pos);
    }
}

// === WHILE LOOP ===
static void compile_while(Compiler* c, ASTNode* n) {
    static int lbl = 0;
    int id = lbl++;
    
    if (c->mode == OUT_C) {
        indent(c); emit(c, "while ("); compile_expr(c, n->left); emit(c, ") {\n");
        c->indent++;
        compile_node(c, n->right);
        c->indent--;
        indent(c); emit(c, "}\n");
    }
    else if (c->mode == OUT_ASM) {
        emit(c, ".Lw%d:\n", id);
        compile_expr(c, n->left);
        emit(c, "    cmp rax,0\n    je .Lwe%d\n", id);
        compile_node(c, n->right);
        emit(c, "    jmp .Lw%d\n.Lwe%d:\n", id, id);
    }
    else if (c->mc) {
        int start_pos = c->mc->size;
        
        compile_expr(c, n->left);
        encode_cmp_rax_zero(c->mc);
        
        int je_pos = c->mc->size;
        encode_je_rel32(c->mc, 0);  // placeholder
        
        compile_node(c, n->right);
        
        int jmp_pos = c->mc->size;
        encode_jmp_rel32(c->mc, 0);  // placeholder
        patch_jump_offset(c->mc, jmp_pos + 1, start_pos);
        
        int end_pos = c->mc->size;
        patch_jump_offset(c->mc, je_pos + 2, end_pos);
    }
}

// === FOR LOOP ===
static void compile_for(Compiler* c, ASTNode* n) {
    static int lbl = 0;
    int id = lbl++;
    
    if (c->mode == OUT_C) {
        indent(c); emit(c, "for (");
        if (n->left) compile_expr(c, n->left);
        emit(c, "; ");
        if (n->extra && n->extra->left) compile_expr(c, n->extra->left);
        emit(c, "; ");
        if (n->extra && n->extra->right) compile_expr(c, n->extra->right);
        emit(c, ") {\n");
        c->indent++;
        compile_node(c, n->right);
        c->indent--;
        indent(c); emit(c, "}\n");
    }
    else if (c->mode == OUT_ASM) {
        if (n->left) compile_node(c, n->left);
        emit(c, ".Lf%d:\n", id);
        if (n->extra && n->extra->left) {
            compile_expr(c, n->extra->left);
            emit(c, "    cmp rax,0\n    je .Lfe%d\n", id);
        }
        compile_node(c, n->right);
        if (n->extra && n->extra->right) compile_node(c, n->extra->right);
        emit(c, "    jmp .Lf%d\n.Lfe%d:\n", id, id);
    }
    else if (c->mc) {
        if (n->left) compile_node(c, n->left);
        
        int start_pos = c->mc->size;
        
        int je_pos = -1;
        if (n->extra && n->extra->left) {
            compile_expr(c, n->extra->left);
            encode_cmp_rax_zero(c->mc);
            je_pos = c->mc->size;
            encode_je_rel32(c->mc, 0);
        }
        
        compile_node(c, n->right);
        
        if (n->extra && n->extra->right) compile_node(c, n->extra->right);
        
        int jmp_pos = c->mc->size;
        encode_jmp_rel32(c->mc, 0);
        patch_jump_offset(c->mc, jmp_pos + 1, start_pos);
        
        if (je_pos >= 0) {
            int end_pos = c->mc->size;
            patch_jump_offset(c->mc, je_pos + 2, end_pos);
        }
    }
}

// === RETURN ===
static void compile_return(Compiler* c, ASTNode* n) {
    if (c->mode == OUT_C) {
        indent(c); emit(c, "return ");
        if (n->left) compile_expr(c, n->left);
        else emit(c, "0");
        emit(c, ";\n");
    }
    else if (c->mode == OUT_ASM) {
        if (n->left) compile_expr(c, n->left);
        else emit(c, "    xor rax,rax\n");
        emit(c, "    leave\n    ret\n");
    }
    else if (c->mc) {
        if (n->left) compile_expr(c, n->left);
        else encode_xor_rax_rax(c->mc);
        encode_leave(c->mc);
        encode_ret(c->mc);
    }
}

// === FUNCTION DECLARATION ===
static void compile_func(Compiler* c, ASTNode* n) {
    const char* name = n->value ? n->value : "func";
    
    if (c->mode == OUT_C) {
        emit(c, "int %s() {\n", name);
        c->indent++;
        compile_node(c, n->right);
        c->indent--;
        emit(c, "    return 0;\n}\n\n");
    }
    else if (c->mode == OUT_ASM) {
        emit(c, "%s:\n    push rbp\n    mov rbp,rsp\n    sub rsp,256\n", name);
        compile_node(c, n->right);
        emit(c, "    xor rax,rax\n    leave\n    ret\n\n");
    }
    else if (c->mc) {
        encode_push_rbp(c->mc);
        encode_mov_rbp_rsp(c->mc);
        encode_sub_rsp_imm8(c->mc, 128);
        compile_node(c, n->right);
        encode_xor_rax_rax(c->mc);
        encode_leave(c->mc);
        encode_ret(c->mc);
    }
}

// === NODE DISPATCHER ===
static void compile_node(Compiler* c, ASTNode* n) {
    while (n) {
        switch (n->type) {
            case PROGRAM_NODE: compile_node(c, n->left); break;
            case FN_CALL_NODE: compile_call(c, n); break;
            case FN_DECL_NODE: case FN_DECL_SPANISH_NODE: compile_func(c, n); break;
            case VAR_DECL_NODE: compile_var(c, n, 0); break;
            case VAR_DECL_SPANISH_NODE: compile_var(c, n, 1); break;
            case ASSIGN_NODE: compile_assign(c, n); break;
            case IF_NODE: case IF_SPANISH_NODE: compile_if(c, n); break;
            case WHILE_NODE: case WHILE_SPANISH_NODE: compile_while(c, n); break;
            case FOR_NODE: case FOR_SPANISH_NODE: compile_for(c, n); break;
            case RETURN_NODE: compile_return(c, n); break;
            case BREAK_NODE:
                if (c->mode == OUT_C) { indent(c); emit(c, "break;\n"); }
                break;
            case CONTINUE_NODE:
                if (c->mode == OUT_C) { indent(c); emit(c, "continue;\n"); }
                break;
            default: break;
        }

        // Use 'next' for sibling chaining
        n = n->next;
    }
}

// === MAIN WRAPPER ===
static void compile_main(Compiler* c, ASTNode* ast) {
    if (c->mode == OUT_C) {
        emit(c, "int main() {\n");
        c->indent = 1;
    } else if (c->mode == OUT_ASM) {
        // Emit main label and prologue BEFORE the code
        emit(c, "main:\n");
        emit(c, "    push rbp\n");
        emit(c, "    mov rbp, rsp\n");
        emit(c, "    sub rsp, 256\n");
    } else if (c->mode == OUT_ELF && c->mc) {
        encode_push_rbp(c->mc);
        encode_mov_rbp_rsp(c->mc);
        encode_sub_rsp_imm8(c->mc, 128);
    } else if (c->mode == OUT_STANDALONE && c->mc) {
        // Standalone: no frame setup needed, we use _start entry
        // Just set up stack for local variables
        encode_sub_rsp_imm8(c->mc, 128);
    }

    compile_node(c, ast);

    if (c->mode == OUT_C) {
        emit(c, "    return 0;\n}\n");
    } else if (c->mode == OUT_ASM) {
        // Emit epilogue after the code
        emit(c, "    xor rax, rax\n");
        emit(c, "    leave\n");
        emit(c, "    ret\n");
    } else if (c->mode == OUT_ELF && c->mc) {
        encode_xor_rax_rax(c->mc);
        encode_leave(c->mc);
        encode_ret(c->mc);
    } else if (c->mode == OUT_STANDALONE && c->mc) {
        // Standalone: use sys_exit(0) syscall
        encode_mov_rdi_imm64(c->mc, 0);   // RDI = 0 (exit code)
        encode_mov_rax_imm32(c->mc, 60);  // RAX = 60 (sys_exit)
        encode_syscall(c->mc);
    }
}

// === PUBLIC API ===
int compile_viva_to_c(const char* code, const char* outfile) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_C);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}

int compile_viva_to_asm(const char* code, const char* outfile) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_ASM);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}

int compile_viva_to_elf(const char* code, const char* outfile) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_ELF);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    c->plat = PLATFORM_LINUX;
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}

int compile_viva_to_platform(const char* code, const char* outfile, PlatformTarget plat) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_ELF);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    c->plat = plat;
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}

int compile_viva_to_standalone(const char* code, const char* outfile) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_STANDALONE);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    c->plat = PLATFORM_LINUX;
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}

int compile_viva_to_standalone_platform(const char* code, const char* outfile, PlatformTarget platform) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_STANDALONE);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    c->plat = platform;
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}
