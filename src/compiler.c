// src/compiler.c - Fixed & Refactored
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <stdint.h>
#include "../include/lexer.h"
#include "../include/parser.h"
#include "../include/compiler.h"
#include "../include/machine_code.h"

#define MAX_VARS 100
#define MAX_STRS 100
#define MAX_BUF 16384

typedef enum { OUT_C, OUT_ASM, OUT_ELF } OutMode;

typedef struct { char name[64]; int is_str; int offset; } Var;
typedef struct { char val[256]; char lbl[32]; } Str;

typedef struct {
    FILE* f;
    OutMode mode;
    PlatformTarget plat;
    int indent;
    Var vars[MAX_VARS];
    int nvar;
    Str strs[MAX_STRS];
    int nstr;
    char buf[MAX_BUF];
    int bufpos;
    char outname[256];
    MachineCode* mc;
    ELFFile* elf;
    int stack_off;
} Compiler;

// Forward declarations
static void compile_node(Compiler* c, ASTNode* n);
static void compile_expr(Compiler* c, ASTNode* n);

static void emit(Compiler* c, const char* fmt, ...) {
    va_list a; va_start(a, fmt);
    if (c->mode == OUT_ASM) {
        int r = MAX_BUF - c->bufpos;
        int n = vsnprintf(c->buf + c->bufpos, r, fmt, a);
        if (n > 0 && n < r) c->bufpos += n;
    } else {
        vfprintf(c->f, fmt, a);
    }
    va_end(a);
}

static void indent(Compiler* c) {
    for (int i = 0; i < c->indent; i++) emit(c, "    ");
}

static int find_var(Compiler* c, const char* name) {
    for (int i = 0; i < c->nvar; i++)
        if (strcmp(c->vars[i].name, name) == 0) return i;
    return -1;
}

static int add_var(Compiler* c, const char* name, int is_str) {
    if (c->nvar >= MAX_VARS) return -1;
    strncpy(c->vars[c->nvar].name, name, 63);
    c->vars[c->nvar].is_str = is_str;
    c->stack_off -= 8;
    c->vars[c->nvar].offset = c->stack_off;
    return c->nvar++;
}

static int get_var_off(Compiler* c, const char* name) {
    int i = find_var(c, name);
    return (i >= 0) ? c->vars[i].offset : -8;
}

static int is_var_str(Compiler* c, const char* name) {
    int i = find_var(c, name);
    return (i >= 0) ? c->vars[i].is_str : 0;
}

static char* add_str(Compiler* c, const char* s) {
    if (c->nstr >= MAX_STRS) return "str_err";
    static int cnt = 0;
    snprintf(c->strs[c->nstr].lbl, 32, "str_%d", cnt++);
    const char* p = (s[0] == '"') ? s + 1 : s;
    strncpy(c->strs[c->nstr].val, p, 255);
    size_t len = strlen(c->strs[c->nstr].val);
    if (len > 0 && c->strs[c->nstr].val[len-1] == '"')
        c->strs[c->nstr].val[len-1] = '\0';
    return c->strs[c->nstr++].lbl;
}

static Compiler* init_compiler(const char* outfile, OutMode mode) {
    Compiler* c = calloc(1, sizeof(Compiler));
    if (!c) return NULL;
    c->mode = mode;
    c->plat = PLATFORM_LINUX;
    strncpy(c->outname, outfile, 255);
    
    if (mode == OUT_ELF) {
        c->mc = init_machine_code();
        c->elf = init_elf_file();
    }
    
    c->f = fopen(outfile, "w");
    if (!c->f) { free(c); return NULL; }
    
    if (mode == OUT_C) {
        fprintf(c->f,
            "// Generated by Viva Colombia compiler\n"
            "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n"
            "void prt(char* s){printf(\"%%s\",s);}\n"
            "void prtln(char* s){printf(\"%%s\\n\",s);}\n"
            "void prtnum(int n){printf(\"%%d\",n);}\n"
            "void prtlnnum(int n){printf(\"%%d\\n\",n);}\n"
            "void bolivar(){printf(\"Simon Bolivar: Libertador\\n\");}\n"
            "void narino(){printf(\"Francisco Narino: Heroe\\n\");}\n"
            "void cano(){printf(\"Maria Cano: Lider\\n\");}\n"
            "void gaitan(){printf(\"Jorge Gaitan: Lider politico\\n\");}\n"
            "void garcia(){printf(\"Gabriel Garcia Marquez: Nobel\\n\");}\n\n");
    } else if (mode == OUT_ASM) {
        fprintf(c->f,
            "; Generated by Viva Colombia\n"
            "section .data\n"
            "    fmt_s db \"%%s\",10,0\n"
            "    fmt_d db \"%%d\",10,0\n"
            "section .text\n"
            "    global main\n"
            "    extern printf\n\n");
    }
    return c;
}

static void finish_compiler(Compiler* c) {
    if (!c) return;
    if (c->mode == OUT_ASM && c->bufpos > 0)
        fwrite(c->buf, 1, c->bufpos, c->f);
    if (c->mode == OUT_ELF && c->elf && c->mc) {
        create_text_section(c->elf, c->mc);
        create_symbol_table(c->elf);
        write_complete_elf_file(c->elf, c->outname);
    }
    if (c->f) fclose(c->f);
    if (c->mc) free_machine_code(c->mc);
    if (c->elf) free_elf_file(c->elf);
    free(c);
}
static void compile_expr(Compiler* c, ASTNode* n) {
    if (!n) return;
    
    if (n->type == NUMBER_NODE) {
        if (c->mode == OUT_C) emit(c, "%s", n->value);
        else if (c->mode == OUT_ASM) emit(c, "    mov rax, %s\n", n->value);
        else if (c->mc) encode_mov_rax_imm32(c->mc, atoi(n->value));
    }
    else if (n->type == STRING_LITERAL_NODE) {
        if (c->mode == OUT_C) emit(c, "%s", n->value);
        else if (c->mode == OUT_ASM) {
            char* l = add_str(c, n->value);
            emit(c, "    lea rax, [%s]\n", l);
        }
    }
    else if (n->type == IDENTIFIER_NODE) {
        if (n->value[0] == '"') {
            if (c->mode == OUT_C) emit(c, "%s", n->value);
            else if (c->mode == OUT_ASM) {
                char* l = add_str(c, n->value);
                emit(c, "    lea rax, [%s]\n", l);
            }
        } else {
            if (c->mode == OUT_C) emit(c, "%s", n->value);
            else if (c->mode == OUT_ASM) {
                int off = get_var_off(c, n->value);
                emit(c, "    mov rax, [rbp%+d]\n", off);
            }
            else if (c->mc) {
                int off = get_var_off(c, n->value);
                encode_mov_rax_from_memory(c->mc, off);
            }
        }
    }
    else if (n->type == BINARY_OP_NODE) {
        if (c->mode == OUT_C) {
            emit(c, "(");
            compile_expr(c, n->left);
            emit(c, " %s ", n->value ? n->value : "+");
            compile_expr(c, n->right);
            emit(c, ")");
        }
        else if (c->mode == OUT_ASM) {
            compile_expr(c, n->left);
            emit(c, "    push rax\n");
            compile_expr(c, n->right);
            emit(c, "    mov rbx, rax\n    pop rax\n");
            if (!n->value) return;
            if (strcmp(n->value, "+") == 0) emit(c, "    add rax, rbx\n");
            else if (strcmp(n->value, "-") == 0) emit(c, "    sub rax, rbx\n");
            else if (strcmp(n->value, "*") == 0) emit(c, "    imul rax, rbx\n");
            else if (strcmp(n->value, "/") == 0) emit(c, "    xor rdx,rdx\n    idiv rbx\n");
            else if (strcmp(n->value, ">") == 0) emit(c, "    cmp rax,rbx\n    setg al\n    movzx rax,al\n");
            else if (strcmp(n->value, "<") == 0) emit(c, "    cmp rax,rbx\n    setl al\n    movzx rax,al\n");
            else if (strcmp(n->value, "==") == 0) emit(c, "    cmp rax,rbx\n    sete al\n    movzx rax,al\n");
            else if (strcmp(n->value, "!=") == 0) emit(c, "    cmp rax,rbx\n    setne al\n    movzx rax,al\n");
            else if (strcmp(n->value, ">=") == 0) emit(c, "    cmp rax,rbx\n    setge al\n    movzx rax,al\n");
            else if (strcmp(n->value, "<=") == 0) emit(c, "    cmp rax,rbx\n    setle al\n    movzx rax,al\n");
        }
        else if (c->mc) {
            compile_expr(c, n->left);
            encode_mov_memory_from_rax(c->mc, -200); // temp
            compile_expr(c, n->right);
            encode_mov_rbx_imm32(c->mc, 0);
            encode_mov_rax_from_memory(c->mc, -200);
            if (n->value && strcmp(n->value, "+") == 0) encode_add_rax_rbx(c->mc);
            else if (n->value && strcmp(n->value, "-") == 0) encode_sub_rax_rbx(c->mc);
            else if (n->value && strcmp(n->value, "*") == 0) encode_mul_rbx(c->mc);
            else if (n->value && strcmp(n->value, "/") == 0) encode_div_rbx(c->mc);
        }
    }
    else if (n->type == UNARY_OP_NODE) {
        ASTNode* op = n->right ? n->right : n->left;
        if (c->mode == OUT_C) {
            if (n->value && (strcmp(n->value,"!")==0 || strcmp(n->value,"no")==0)) emit(c, "!");
            else if (n->value && strcmp(n->value,"-")==0) emit(c, "-");
            compile_expr(c, op);
        } else if (c->mode == OUT_ASM) {
            compile_expr(c, op);
            if (n->value && (strcmp(n->value,"!")==0 || strcmp(n->value,"no")==0))
                emit(c, "    cmp rax,0\n    sete al\n    movzx rax,al\n");
            else if (n->value && strcmp(n->value,"-")==0)
                emit(c, "    neg rax\n");
        }
    }
}

static void compile_call(Compiler* c, ASTNode* n) {
    if (!n || !n->value) return;
    const char* fn = n->value;
    
    if (c->mode == OUT_C) {
        indent(c);
        if (strcmp(fn,"println")==0 || strcmp(fn,"print")==0) {
            int ln = (strcmp(fn,"println")==0);
            if (n->left && n->left->type == NUMBER_NODE)
                emit(c, "prt%snum(%s);\n", ln?"ln":"", n->left->value);
            else if (n->left && (n->left->type == STRING_LITERAL_NODE || 
                     (n->left->type == IDENTIFIER_NODE && n->left->value[0]=='"')))
                emit(c, "prt%s(%s);\n", ln?"ln":"", n->left->value);
            else if (n->left && n->left->type == IDENTIFIER_NODE) {
                if (is_var_str(c, n->left->value))
                    emit(c, "prt%s(%s);\n", ln?"ln":"", n->left->value);
                else
                    emit(c, "prt%snum(%s);\n", ln?"ln":"", n->left->value);
            }
            else emit(c, "prt%s(\"\");\n", ln?"ln":"");
        }
        else if (strstr(fn,"bolivar")) emit(c, "bolivar();\n");
        else if (strstr(fn,"narino")) emit(c, "narino();\n");
        else if (strstr(fn,"cano")) emit(c, "cano();\n");
        else if (strstr(fn,"gaitan")) emit(c, "gaitan();\n");
        else if (strstr(fn,"garcia")) emit(c, "garcia();\n");
        else emit(c, "%s();\n", fn);
    }
    else if (c->mode == OUT_ASM) {
        emit(c, "    ; call %s\n", fn);
        if (strcmp(fn,"println")==0 || strcmp(fn,"print")==0) {
            if (n->left && n->left->type == NUMBER_NODE) {
                emit(c, "    mov rdi, fmt_d\n    mov rsi, %s\n", n->left->value);
            } else if (n->left) {
                char* l = add_str(c, n->left->value);
                emit(c, "    mov rdi, fmt_s\n    lea rsi, [%s]\n", l);
            }
            emit(c, "    xor rax,rax\n    call printf\n");
        }
    }
    else if (c->mc) {
        if (strcmp(fn,"println")==0 || strcmp(fn,"print")==0) {
            if (n->left && n->left->type == NUMBER_NODE) {
                encode_mov_rdi_imm64(c->mc, 0);
                encode_mov_rax_imm32(c->mc, atoi(n->left->value));
            }
            encode_call_external(c->mc);
        } else {
            encode_call_external(c->mc);
        }
    }
}

static void compile_var(Compiler* c, ASTNode* n, int spanish) {
    if (!n || !n->value) return;
    int is_str = 0;
    
    if (c->mode == OUT_C) {
        indent(c);
        if (n->left && (n->left->type == STRING_LITERAL_NODE ||
            (n->left->type == IDENTIFIER_NODE && n->left->value[0]=='"'))) {
            emit(c, "char* %s = %s;\n", n->value, n->left->value);
            is_str = 1;
        } else if (n->left) {
            emit(c, "int %s = ", n->value);
            compile_expr(c, n->left);
            emit(c, ";\n");
        } else {
            emit(c, "int %s = 0;\n", n->value);
        }
    }
    else if (c->mode == OUT_ASM) {
        int off = c->stack_off - 8;
        emit(c, "    ; var %s\n", n->value);
        if (n->left) {
            compile_expr(c, n->left);
            emit(c, "    mov [rbp%+d], rax\n", off);
        } else {
            emit(c, "    mov qword [rbp%+d], 0\n", off);
        }
    }
    else if (c->mc && n->left) {
        compile_expr(c, n->left);
        encode_mov_memory_from_rax(c->mc, c->stack_off - 8);
    }
    add_var(c, n->value, is_str);
}

static void compile_assign(Compiler* c, ASTNode* n) {
    if (!n || !n->value || !n->left) return;
    
    if (c->mode == OUT_C) {
        indent(c);
        emit(c, "%s = ", n->value);
        compile_expr(c, n->left);
        emit(c, ";\n");
    }
    else if (c->mode == OUT_ASM) {
        int off = get_var_off(c, n->value);
        compile_expr(c, n->left);
        emit(c, "    mov [rbp%+d], rax\n", off);
    }
    else if (c->mc) {
        int off = get_var_off(c, n->value);
        compile_expr(c, n->left);
        encode_mov_memory_from_rax(c->mc, off);
    }
}

static void compile_if(Compiler* c, ASTNode* n) {
    static int lbl = 0;
    int id = lbl++;
    
    if (c->mode == OUT_C) {
        indent(c); emit(c, "if ("); compile_expr(c, n->left); emit(c, ") {\n");
        c->indent++;
        compile_node(c, n->right);
        c->indent--;
        indent(c); emit(c, "}");
        if (n->extra) {
            emit(c, " else {\n");
            c->indent++;
            compile_node(c, n->extra);
            c->indent--;
            indent(c); emit(c, "}");
        }
        emit(c, "\n");
    }
    else if (c->mode == OUT_ASM) {
        compile_expr(c, n->left);
        emit(c, "    cmp rax, 0\n    je .Lelse%d\n", id);
        compile_node(c, n->right);
        emit(c, "    jmp .Lend%d\n.Lelse%d:\n", id, id);
        if (n->extra) compile_node(c, n->extra);
        emit(c, ".Lend%d:\n", id);
    }
    else if (c->mc) {
        compile_expr(c, n->left);
        uint8_t cmp[] = {0x48,0x83,0xF8,0x00};
        uint8_t jz[] = {0x0F,0x84,0,0,0,0};
        append_bytes(c->mc, cmp, 4);
        int jzpos = c->mc->size;
        append_bytes(c->mc, jz, 6);
        compile_node(c, n->right);
        int32_t off = c->mc->size - (jzpos + 6);
        memcpy(c->mc->code + jzpos + 2, &off, 4);
    }
}

static void compile_while(Compiler* c, ASTNode* n) {
    static int lbl = 0;
    int id = lbl++;
    
    if (c->mode == OUT_C) {
        indent(c); emit(c, "while ("); compile_expr(c, n->left); emit(c, ") {\n");
        c->indent++;
        compile_node(c, n->right);
        c->indent--;
        indent(c); emit(c, "}\n");
    }
    else if (c->mode == OUT_ASM) {
        emit(c, ".Lw%d:\n", id);
        compile_expr(c, n->left);
        emit(c, "    cmp rax,0\n    je .Lwe%d\n", id);
        compile_node(c, n->right);
        emit(c, "    jmp .Lw%d\n.Lwe%d:\n", id, id);
    }
    else if (c->mc) {
        int start = c->mc->size;
        compile_expr(c, n->left);
        uint8_t cmp[] = {0x48,0x83,0xF8,0x00};
        uint8_t jz[] = {0x0F,0x84,0,0,0,0};
        append_bytes(c->mc, cmp, 4);
        int jzpos = c->mc->size;
        append_bytes(c->mc, jz, 6);
        compile_node(c, n->right);
        uint8_t jmp[] = {0xE9,0,0,0,0};
        int jmppos = c->mc->size;
        append_bytes(c->mc, jmp, 5);
        int32_t off1 = (jmppos+5) - (jzpos+6);
        int32_t off2 = start - (jmppos+5);
        memcpy(c->mc->code + jzpos + 2, &off1, 4);
        memcpy(c->mc->code + jmppos + 1, &off2, 4);
    }
}

static void compile_for(Compiler* c, ASTNode* n) {
    static int lbl = 0;
    int id = lbl++;
    
    if (c->mode == OUT_C) {
        indent(c); emit(c, "for (");
        if (n->left) compile_expr(c, n->left);
        emit(c, "; ");
        if (n->extra && n->extra->left) compile_expr(c, n->extra->left);
        emit(c, "; ");
        if (n->extra && n->extra->right) compile_expr(c, n->extra->right);
        emit(c, ") {\n");
        c->indent++;
        compile_node(c, n->right);
        c->indent--;
        indent(c); emit(c, "}\n");
    }
    else if (c->mode == OUT_ASM) {
        if (n->left) compile_node(c, n->left);
        emit(c, ".Lf%d:\n", id);
        if (n->extra && n->extra->left) {
            compile_expr(c, n->extra->left);
            emit(c, "    cmp rax,0\n    je .Lfe%d\n", id);
        }
        compile_node(c, n->right);
        if (n->extra && n->extra->right) compile_node(c, n->extra->right);
        emit(c, "    jmp .Lf%d\n.Lfe%d:\n", id, id);
    }
}

static void compile_return(Compiler* c, ASTNode* n) {
    if (c->mode == OUT_C) {
        indent(c); emit(c, "return ");
        if (n->left) compile_expr(c, n->left);
        else emit(c, "0");
        emit(c, ";\n");
    }
    else if (c->mode == OUT_ASM) {
        if (n->left) compile_expr(c, n->left);
        else emit(c, "    xor rax,rax\n");
        emit(c, "    leave\n    ret\n");
    }
    else if (c->mc) {
        if (n->left) compile_expr(c, n->left);
        else encode_mov_rax_imm32(c->mc, 0);
        encode_pop_rbp(c->mc);
        encode_ret(c->mc);
    }
}

static void compile_func(Compiler* c, ASTNode* n) {
    const char* name = n->value ? n->value : "func";
    
    if (c->mode == OUT_C) {
        emit(c, "int %s() {\n", name);
        c->indent++;
        compile_node(c, n->right);
        c->indent--;
        emit(c, "    return 0;\n}\n\n");
    }
    else if (c->mode == OUT_ASM) {
        emit(c, "%s:\n    push rbp\n    mov rbp,rsp\n    sub rsp,256\n", name);
        compile_node(c, n->right);
        emit(c, "    xor rax,rax\n    leave\n    ret\n");
    }
    else if (c->mc) {
        encode_push_rbp(c->mc);
        encode_mov_rbp_rsp(c->mc);
        compile_node(c, n->right);
        encode_mov_rax_imm32(c->mc, 0);
        encode_pop_rbp(c->mc);
        encode_ret(c->mc);
    }
}

static void compile_node(Compiler* c, ASTNode* n) {
    while (n) {
        switch (n->type) {
            case PROGRAM_NODE: compile_node(c, n->left); break;
            case FN_CALL_NODE: compile_call(c, n); break;
            case FN_DECL_NODE: case FN_DECL_SPANISH_NODE: compile_func(c, n); break;
            case VAR_DECL_NODE: compile_var(c, n, 0); break;
            case VAR_DECL_SPANISH_NODE: compile_var(c, n, 1); break;
            case ASSIGN_NODE: compile_assign(c, n); break;
            case IF_NODE: case IF_SPANISH_NODE: compile_if(c, n); break;
            case WHILE_NODE: case WHILE_SPANISH_NODE: compile_while(c, n); break;
            case FOR_NODE: case FOR_SPANISH_NODE: compile_for(c, n); break;
            case RETURN_NODE: compile_return(c, n); break;
            default: break;
        }
        n = n->right;
    }
}

static void compile_main(Compiler* c, ASTNode* ast) {
    if (c->mode == OUT_C) {
        emit(c, "int main() {\n");
        c->indent = 1;
    } else if (c->mode == OUT_ASM) {
        emit(c, "main:\n    push rbp\n    mov rbp,rsp\n    sub rsp,256\n");
    } else if (c->mc) {
        encode_push_rbp(c->mc);
        encode_mov_rbp_rsp(c->mc);
    }
    
    compile_node(c, ast);
    
    if (c->mode == OUT_C) {
        emit(c, "    return 0;\n}\n");
    } else if (c->mode == OUT_ASM) {
        emit(c, "    xor rax,rax\n    leave\n    ret\n");
    } else if (c->mc) {
        encode_mov_rax_imm32(c->mc, 0);
        encode_pop_rbp(c->mc);
        encode_ret(c->mc);
    }
}

// Public API functions
int compile_viva_to_c(const char* code, const char* outfile) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_C);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}

int compile_viva_to_asm(const char* code, const char* outfile) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_ASM);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}

int compile_viva_to_elf(const char* code, const char* outfile) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_ELF);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    c->plat = PLATFORM_LINUX;
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}

int compile_viva_to_platform(const char* code, const char* outfile, PlatformTarget plat) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_ELF);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    c->plat = plat;
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}