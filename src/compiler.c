// src/compiler.c - EXPANDED for Phase 4
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <stdint.h>
#include "../include/lexer.h"
#include "../include/parser.h"
#include "../include/compiler.h"
#include "../include/machine_code.h"

#define MAX_VARS 100
#define MAX_STRS 100
#define MAX_BUF 16384
#define MAX_LABELS 256
#define MAX_FUNCS 64
#define MAX_PARAMS 8

typedef enum { OUT_C, OUT_ASM, OUT_ELF } OutMode;

typedef struct { char name[64]; int is_str; int offset; } Var;
typedef struct { char val[256]; char lbl[32]; int offset; } Str;
typedef struct { char name[32]; int offset; } Label;
typedef struct {
    char name[64];
    int code_offset;      // Position in machine code
    int param_count;
    char params[MAX_PARAMS][64];
} UserFunc;

typedef struct {
    FILE* f;
    OutMode mode;
    PlatformTarget plat;
    int indent;
    Var vars[MAX_VARS];
    int nvar;
    Str strs[MAX_STRS];
    int nstr;
    Label labels[MAX_LABELS];
    int nlbl;
    char buf[MAX_BUF];
    int bufpos;
    char outname[256];
    MachineCode* mc;
    ELFFile* elf;
    int stack_off;
    int data_size;
    UserFunc funcs[MAX_FUNCS];
    int nfunc;
    int in_function;  // Track if we're inside a function
} Compiler;

// Forward declarations
static void compile_node(Compiler* c, ASTNode* n);
static void compile_expr(Compiler* c, ASTNode* n);

// === EMIT HELPERS ===
static void emit(Compiler* c, const char* fmt, ...) {
    va_list a;
    va_start(a, fmt);
    if (c->mode == OUT_ASM) {
        int r = MAX_BUF - c->bufpos;
        int n = vsnprintf(c->buf + c->bufpos, r, fmt, a);
        if (n > 0 && n < r) c->bufpos += n;
    } else if (c->mode == OUT_C) {
        vfprintf(c->f, fmt, a);
    }
    va_end(a);
}

static void indent(Compiler* c) {
    for (int i = 0; i < c->indent; i++) emit(c, "    ");
}

// === VARIABLE MANAGEMENT ===
static int find_var(Compiler* c, const char* name) {
    for (int i = 0; i < c->nvar; i++)
        if (strcmp(c->vars[i].name, name) == 0) return i;
    return -1;
}

static int add_var(Compiler* c, const char* name, int is_str) {
    if (c->nvar >= MAX_VARS) return -1;
    strncpy(c->vars[c->nvar].name, name, 63);
    c->vars[c->nvar].is_str = is_str;
    c->stack_off -= 8;
    c->vars[c->nvar].offset = c->stack_off;
    return c->nvar++;
}

static int get_var_off(Compiler* c, const char* name) {
    int i = find_var(c, name);
    return (i >= 0) ? c->vars[i].offset : -8;
}

static int is_var_str(Compiler* c, const char* name) {
    int i = find_var(c, name);
    return (i >= 0) ? c->vars[i].is_str : 0;
}

// === STRING MANAGEMENT ===
static char* add_str(Compiler* c, const char* s) {
    if (c->nstr >= MAX_STRS) return "str_err";
    static int cnt = 0;
    snprintf(c->strs[c->nstr].lbl, 32, "str_%d", cnt++);
    
    const char* p = (s[0] == '"') ? s + 1 : s;
    strncpy(c->strs[c->nstr].val, p, 255);
    size_t len = strlen(c->strs[c->nstr].val);
    if (len > 0 && c->strs[c->nstr].val[len-1] == '"')
        c->strs[c->nstr].val[len-1] = '\0';
    
    c->strs[c->nstr].offset = c->data_size;
    c->data_size += strlen(c->strs[c->nstr].val) + 1;
    
    return c->strs[c->nstr++].lbl;
}

static int get_str_offset(Compiler* c, const char* lbl) {
    for (int i = 0; i < c->nstr; i++)
        if (strcmp(c->strs[i].lbl, lbl) == 0) return c->strs[i].offset;
    return 0;
}

// === FUNCTION MANAGEMENT ===
static int find_func(Compiler* c, const char* name) {
    for (int i = 0; i < c->nfunc; i++)
        if (strcmp(c->funcs[i].name, name) == 0) return i;
    return -1;
}

static int add_func(Compiler* c, const char* name, int code_off) {
    if (c->nfunc >= MAX_FUNCS) return -1;
    strncpy(c->funcs[c->nfunc].name, name, 63);
    c->funcs[c->nfunc].code_offset = code_off;
    c->funcs[c->nfunc].param_count = 0;
    return c->nfunc++;
}

static void add_func_param(Compiler* c, int func_idx, const char* param_name) {
    if (func_idx < 0 || func_idx >= c->nfunc) return;
    UserFunc* f = &c->funcs[func_idx];
    if (f->param_count >= MAX_PARAMS) return;
    strncpy(f->params[f->param_count++], param_name, 63);
}

static UserFunc* get_func(Compiler* c, const char* name) {
    int idx = find_func(c, name);
    return (idx >= 0) ? &c->funcs[idx] : NULL;
}

// === COMPILER INIT/FINISH ===
static Compiler* init_compiler(const char* outfile, OutMode mode) {
    Compiler* c = calloc(1, sizeof(Compiler));
    if (!c) return NULL;
    c->mode = mode;
    c->plat = PLATFORM_LINUX;
    strncpy(c->outname, outfile, 255);
    
    if (mode == OUT_ELF) {
        c->mc = init_machine_code();
        c->elf = init_elf_file();
    }
    
    c->f = fopen(outfile, "wb");
    if (!c->f) { free(c); return NULL; }
    
    if (mode == OUT_C) {
        fprintf(c->f,
            "// Generated by Viva Colombia compiler\n"
            "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n"
            "void prt(char* s){printf(\"%%s\",s);}\n"
            "void prtln(char* s){printf(\"%%s\\n\",s);}\n"
            "void prtnum(int n){printf(\"%%d\",n);}\n"
            "void prtlnnum(int n){printf(\"%%d\\n\",n);}\n"
            "void bolivar(){printf(\"Simon Bolivar: Libertador\\n\");}\n"
            "void narino(){printf(\"Francisco Narino: Heroe\\n\");}\n"
            "void cano(){printf(\"Maria Cano: Lider\\n\");}\n"
            "void gaitan(){printf(\"Jorge Gaitan: Lider politico\\n\");}\n"
            "void garcia(){printf(\"Gabriel Garcia Marquez: Nobel\\n\");}\n\n");
    } else if (mode == OUT_ASM) {
        fprintf(c->f,
            "; Generated by Viva Colombia\n"
            "section .data\n"
            "    fmt_s db \"%%s\",10,0\n"
            "    fmt_d db \"%%d\",10,0\n");
    }
    return c;
}

static void write_asm_strings(Compiler* c) {
    if (c->mode != OUT_ASM) return;
    for (int i = 0; i < c->nstr; i++) {
        fprintf(c->f, "    %s db \"%s\",0\n", c->strs[i].lbl, c->strs[i].val);
    }
    fprintf(c->f,
        "section .text\n"
        "    global main\n"
        "    extern printf\n\n");
}

static void write_elf_data_section(Compiler* c) {
    if (c->mode != OUT_ELF || c->nstr == 0) return;
    
    uint8_t* data = calloc(1, c->data_size + 1);
    if (!data) return;
    
    int off = 0;
    for (int i = 0; i < c->nstr; i++) {
        size_t len = strlen(c->strs[i].val);
        memcpy(data + off, c->strs[i].val, len);
        data[off + len] = 0;
        off += len + 1;
    }
    
    create_data_section(c->elf, data, c->data_size);
    free(data);
}

static void finish_compiler(Compiler* c) {
    if (!c) return;
    
    if (c->mode == OUT_ASM) {
        write_asm_strings(c);
        if (c->bufpos > 0)
            fwrite(c->buf, 1, c->bufpos, c->f);
    }
    
    if (c->mode == OUT_ELF && c->elf && c->mc) {
        write_elf_data_section(c);
        create_text_section(c->elf, c->mc);
        create_symbol_table(c->elf);
        fclose(c->f);
        c->f = NULL;
        write_complete_elf_file(c->elf, c->outname);
    }
    
    if (c->f) fclose(c->f);
    if (c->mc) free_machine_code(c->mc);
    if (c->elf) free_elf_file(c->elf);
    free(c);
}

// Forward declaration for compile_call (needed for expression)
static void compile_call(Compiler* c, ASTNode* n);

// === EXPRESSION COMPILATION ===
static void compile_expr(Compiler* c, ASTNode* n) {
    if (!n) return;

    // Handle function call as expression (returns value in rax)
    if (n->type == FN_CALL_NODE) {
        compile_call(c, n);
        return;
    }

    if (n->type == NUMBER_NODE) {
        if (c->mode == OUT_C) emit(c, "%s", n->value);
        else if (c->mode == OUT_ASM) emit(c, "    mov rax, %s\n", n->value);
        else if (c->mc) encode_mov_rax_imm32(c->mc, atoi(n->value));
    }
    else if (n->type == STRING_LITERAL_NODE) {
        if (c->mode == OUT_C) emit(c, "%s", n->value);
        else if (c->mode == OUT_ASM) {
            char* l = add_str(c, n->value);
            emit(c, "    lea rax, [%s]\n", l);
        }
        else if (c->mc) {
            char* l = add_str(c, n->value);
            int off = get_str_offset(c, l);
            encode_lea_rax_rip_rel(c->mc, off);
        }
    }
    else if (n->type == IDENTIFIER_NODE) {
        if (n->value && n->value[0] == '"') {
            if (c->mode == OUT_C) emit(c, "%s", n->value);
            else if (c->mode == OUT_ASM) {
                char* l = add_str(c, n->value);
                emit(c, "    lea rax, [%s]\n", l);
            }
            else if (c->mc) {
                char* l = add_str(c, n->value);
                int off = get_str_offset(c, l);
                encode_lea_rax_rip_rel(c->mc, off);
            }
        } else {
            if (c->mode == OUT_C) emit(c, "%s", n->value);
            else if (c->mode == OUT_ASM) {
                int off = get_var_off(c, n->value);
                emit(c, "    mov rax, [rbp%+d]\n", off);
            }
            else if (c->mc) {
                int off = get_var_off(c, n->value);
                encode_mov_rax_from_memory(c->mc, off);
            }
        }
    }
    else if (n->type == BINARY_OP_NODE) {
        if (c->mode == OUT_C) {
            emit(c, "(");
            compile_expr(c, n->left);
            emit(c, " %s ", n->value ? n->value : "+");
            compile_expr(c, n->right);
            emit(c, ")");
        }
        else if (c->mode == OUT_ASM) {
            compile_expr(c, n->left);
            emit(c, "    push rax\n");
            compile_expr(c, n->right);
            emit(c, "    mov rbx, rax\n    pop rax\n");
            
            if (!n->value) return;
            if (strcmp(n->value, "+") == 0) emit(c, "    add rax, rbx\n");
            else if (strcmp(n->value, "-") == 0) emit(c, "    sub rax, rbx\n");
            else if (strcmp(n->value, "*") == 0) emit(c, "    imul rax, rbx\n");
            else if (strcmp(n->value, "/") == 0) emit(c, "    xor rdx,rdx\n    idiv rbx\n");
            else if (strcmp(n->value, "%") == 0) emit(c, "    xor rdx,rdx\n    idiv rbx\n    mov rax,rdx\n");
            else if (strcmp(n->value, ">") == 0) emit(c, "    cmp rax,rbx\n    setg al\n    movzx rax,al\n");
            else if (strcmp(n->value, "<") == 0) emit(c, "    cmp rax,rbx\n    setl al\n    movzx rax,al\n");
            else if (strcmp(n->value, ">=") == 0) emit(c, "    cmp rax,rbx\n    setge al\n    movzx rax,al\n");
            else if (strcmp(n->value, "<=") == 0) emit(c, "    cmp rax,rbx\n    setle al\n    movzx rax,al\n");
            else if (strcmp(n->value, "==") == 0) emit(c, "    cmp rax,rbx\n    sete al\n    movzx rax,al\n");
            else if (strcmp(n->value, "!=") == 0) emit(c, "    cmp rax,rbx\n    setne al\n    movzx rax,al\n");
            else if (strcmp(n->value, "&&") == 0) emit(c, "    and rax,rbx\n");
            else if (strcmp(n->value, "||") == 0) emit(c, "    or rax,rbx\n");
        }
        else if (c->mc) {
            compile_expr(c, n->left);
            encode_push_rax(c->mc);
            compile_expr(c, n->right);
            encode_mov_rbx_rax(c->mc);
            encode_pop_rax(c->mc);
            
            if (!n->value) return;
            if (strcmp(n->value, "+") == 0) encode_add_rax_rbx(c->mc);
            else if (strcmp(n->value, "-") == 0) encode_sub_rax_rbx(c->mc);
            else if (strcmp(n->value, "*") == 0) encode_mul_rbx(c->mc);
            else if (strcmp(n->value, "/") == 0) encode_div_rbx(c->mc);
            else if (strcmp(n->value, "&&") == 0) encode_and_rax_rbx(c->mc);
            else if (strcmp(n->value, "||") == 0) encode_or_rax_rbx(c->mc);
            else if (strcmp(n->value, ">") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_setg_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (strcmp(n->value, "<") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_setl_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (strcmp(n->value, ">=") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_setge_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (strcmp(n->value, "<=") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_setle_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (strcmp(n->value, "==") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_sete_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (strcmp(n->value, "!=") == 0) {
                encode_cmp_rax_rbx(c->mc);
                encode_setne_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
        }
    }
    else if (n->type == UNARY_OP_NODE) {
        ASTNode* op = n->right ? n->right : n->left;
        if (c->mode == OUT_C) {
            if (n->value && (strcmp(n->value,"!")==0 || strcmp(n->value,"no")==0)) emit(c, "!");
            else if (n->value && strcmp(n->value,"-")==0) emit(c, "-");
            compile_expr(c, op);
        }
        else if (c->mode == OUT_ASM) {
            compile_expr(c, op);
            if (n->value && (strcmp(n->value,"!")==0 || strcmp(n->value,"no")==0))
                emit(c, "    cmp rax,0\n    sete al\n    movzx rax,al\n");
            else if (n->value && strcmp(n->value,"-")==0)
                emit(c, "    neg rax\n");
        }
        else if (c->mc) {
            compile_expr(c, op);
            if (n->value && (strcmp(n->value,"!")==0 || strcmp(n->value,"no")==0)) {
                encode_cmp_rax_zero(c->mc);
                encode_sete_al(c->mc);
                encode_movzx_rax_al(c->mc);
            }
            else if (n->value && strcmp(n->value,"-")==0) {
                encode_neg_rax(c->mc);
            }
        }
    }
}
// === FUNCTION CALL ===
static void compile_call(Compiler* c, ASTNode* n) {
    if (!n || !n->value) return;
    const char* fn = n->value;

    // Check if this is a user-defined function
    UserFunc* uf = get_func(c, fn);

    if (c->mode == OUT_C) {
        // Note: indent is NOT called here - caller is responsible for indentation
        // This allows function calls to be used both as statements and expressions
        if (strcmp(fn,"println")==0 || strcmp(fn,"print")==0) {
            int ln = (strcmp(fn,"println")==0);
            if (n->left && n->left->type == NUMBER_NODE)
                emit(c, "prt%snum(%s)", ln?"ln":"", n->left->value);
            else if (n->left && (n->left->type == STRING_LITERAL_NODE ||
                     (n->left->type == IDENTIFIER_NODE && n->left->value[0]=='"')))
                emit(c, "prt%s(%s)", ln?"ln":"", n->left->value);
            else if (n->left && n->left->type == IDENTIFIER_NODE) {
                if (is_var_str(c, n->left->value))
                    emit(c, "prt%s(%s)", ln?"ln":"", n->left->value);
                else
                    emit(c, "prt%snum(%s)", ln?"ln":"", n->left->value);
            }
            else if (n->left && n->left->type == BINARY_OP_NODE) {
                emit(c, "prt%snum(", ln?"ln":"");
                compile_expr(c, n->left);
                emit(c, ")");
            }
            else emit(c, "prt%s(\"\")", ln?"ln":"");
        }
        else if (strstr(fn,"bolivar")) emit(c, "bolivar()");
        else if (strstr(fn,"narino")) emit(c, "narino()");
        else if (strstr(fn,"cano")) emit(c, "cano()");
        else if (strstr(fn,"gaitan")) emit(c, "gaitan()");
        else if (strstr(fn,"garcia")) emit(c, "garcia()");
        else {
            // User-defined function call with multiple arguments
            emit(c, "%s(", fn);
            ASTNode* arg = n->left;
            int first = 1;
            while (arg) {
                if (!first) emit(c, ", ");
                compile_expr(c, arg);
                first = 0;
                arg = arg->next;
            }
            emit(c, ")");
        }
    }
    else if (c->mode == OUT_ASM) {
        emit(c, "    ; call %s\n", fn);
        if (strcmp(fn,"println")==0 || strcmp(fn,"print")==0) {
            if (n->left && n->left->type == NUMBER_NODE) {
                emit(c, "    mov rdi, fmt_d\n    mov rsi, %s\n", n->left->value);
            } else if (n->left && n->left->type == BINARY_OP_NODE) {
                compile_expr(c, n->left);
                emit(c, "    mov rsi, rax\n    mov rdi, fmt_d\n");
            } else if (n->left && n->left->type == IDENTIFIER_NODE && !is_var_str(c, n->left->value)) {
                int off = get_var_off(c, n->left->value);
                emit(c, "    mov rsi, [rbp%+d]\n    mov rdi, fmt_d\n", off);
            } else if (n->left) {
                char* l = add_str(c, n->left->value);
                emit(c, "    mov rdi, fmt_s\n    lea rsi, [%s]\n", l);
            }
            emit(c, "    xor rax,rax\n    call printf\n");
        }
        else if (uf) {
            // User-defined function: pass args in rdi, rsi, rdx, rcx, r8, r9
            static const char* arg_regs[] = {"rdi", "rsi", "rdx", "rcx", "r8", "r9"};
            ASTNode* arg = n->left;
            int arg_idx = 0;
            while (arg && arg_idx < 6) {
                compile_expr(c, arg);
                emit(c, "    mov %s, rax\n", arg_regs[arg_idx]);
                arg = arg->next;
                arg_idx++;
            }
            emit(c, "    call %s\n", fn);
        }
        else {
            emit(c, "    call %s\n", fn);
        }
    }
    else if (c->mc) {
        if (strcmp(fn,"println")==0 || strcmp(fn,"print")==0) {
            if (n->left && n->left->type == NUMBER_NODE) {
                encode_mov_rdi_imm64(c->mc, 0);  // fmt placeholder
                encode_mov_rax_imm32(c->mc, atoi(n->left->value));
                encode_mov_rsi_rax(c->mc);
            } else if (n->left && n->left->type == BINARY_OP_NODE) {
                compile_expr(c, n->left);
                encode_mov_rsi_rax(c->mc);
                encode_mov_rdi_imm64(c->mc, 0);
            } else if (n->left && n->left->type == IDENTIFIER_NODE) {
                int off = get_var_off(c, n->left->value);
                encode_mov_rax_from_memory(c->mc, off);
                encode_mov_rsi_rax(c->mc);
                encode_mov_rdi_imm64(c->mc, 0);
            }
            encode_xor_rax_rax(c->mc);
            add_relocation_entry(c->mc, 1, R_X86_64_PLT32, -4);
            encode_call_rel32(c->mc, 0);
        } else if (uf) {
            // User-defined function call
            // Move argument to rdi (first arg register)
            if (n->left) {
                compile_expr(c, n->left);
                encode_mov_rdi_rax(c->mc);
            }
            // Calculate relative offset and emit call
            int call_pos = c->mc->size;
            int32_t rel_offset = uf->code_offset - (call_pos + 5);  // +5 for call instruction size
            encode_call_rel32(c->mc, rel_offset);
        } else {
            encode_call_external(c->mc);
        }
    }
}

// === VARIABLE DECLARATION ===
static void compile_var(Compiler* c, ASTNode* n, int spanish) {
    if (!n || !n->value) return;
    int is_str = 0;
    
    if (c->mode == OUT_C) {
        indent(c);
        if (n->left && (n->left->type == STRING_LITERAL_NODE ||
            (n->left->type == IDENTIFIER_NODE && n->left->value[0]=='"'))) {
            emit(c, "char* %s = %s;\n", n->value, n->left->value);
            is_str = 1;
        } else if (n->left) {
            emit(c, "int %s = ", n->value);
            compile_expr(c, n->left);
            emit(c, ";\n");
        } else {
            emit(c, "int %s = 0;\n", n->value);
        }
    }
    else if (c->mode == OUT_ASM) {
        int off = c->stack_off - 8;
        emit(c, "    ; var %s\n", n->value);
        if (n->left) {
            if (n->left->type == STRING_LITERAL_NODE ||
                (n->left->type == IDENTIFIER_NODE && n->left->value[0]=='"')) {
                char* l = add_str(c, n->left->value);
                emit(c, "    lea rax, [%s]\n", l);
                is_str = 1;
            } else {
                compile_expr(c, n->left);
            }
            emit(c, "    mov [rbp%+d], rax\n", off);
        } else {
            emit(c, "    mov qword [rbp%+d], 0\n", off);
        }
    }
    else if (c->mc) {
        int off = c->stack_off - 8;
        if (n->left) {
            if (n->left->type == STRING_LITERAL_NODE ||
                (n->left->type == IDENTIFIER_NODE && n->left->value[0]=='"')) {
                char* l = add_str(c, n->left->value);
                int str_off = get_str_offset(c, l);
                encode_lea_rax_rip_rel(c->mc, str_off);
                is_str = 1;
            } else {
                compile_expr(c, n->left);
            }
            encode_mov_memory_from_rax(c->mc, off);
        } else {
            encode_mov_rax_imm32(c->mc, 0);
            encode_mov_memory_from_rax(c->mc, off);
        }
    }
    add_var(c, n->value, is_str);
}

// === ASSIGNMENT ===
static void compile_assign(Compiler* c, ASTNode* n) {
    if (!n || !n->value || !n->left) return;
    
    if (c->mode == OUT_C) {
        indent(c);
        emit(c, "%s = ", n->value);
        compile_expr(c, n->left);
        emit(c, ";\n");
    }
    else if (c->mode == OUT_ASM) {
        int off = get_var_off(c, n->value);
        compile_expr(c, n->left);
        emit(c, "    mov [rbp%+d], rax\n", off);
    }
    else if (c->mc) {
        int off = get_var_off(c, n->value);
        compile_expr(c, n->left);
        encode_mov_memory_from_rax(c->mc, off);
    }
}

// === IF STATEMENT ===
static void compile_if(Compiler* c, ASTNode* n) {
    static int lbl = 0;
    int id = lbl++;
    
    if (c->mode == OUT_C) {
        indent(c); emit(c, "if ("); compile_expr(c, n->left); emit(c, ") {\n");
        c->indent++;
        compile_node(c, n->right);
        c->indent--;
        indent(c); emit(c, "}");
        if (n->extra) {
            emit(c, " else {\n");
            c->indent++;
            compile_node(c, n->extra);
            c->indent--;
            indent(c); emit(c, "}");
        }
        emit(c, "\n");
    }
    else if (c->mode == OUT_ASM) {
        compile_expr(c, n->left);
        emit(c, "    cmp rax, 0\n    je .Lelse%d\n", id);
        compile_node(c, n->right);
        emit(c, "    jmp .Lend%d\n.Lelse%d:\n", id, id);
        if (n->extra) compile_node(c, n->extra);
        emit(c, ".Lend%d:\n", id);
    }
    else if (c->mc) {
        compile_expr(c, n->left);
        encode_cmp_rax_zero(c->mc);
        
        int je_pos = c->mc->size;
        encode_je_rel32(c->mc, 0);  // placeholder
        
        compile_node(c, n->right);
        
        int jmp_pos = c->mc->size;
        encode_jmp_rel32(c->mc, 0);  // placeholder
        
        int else_pos = c->mc->size;
        patch_jump_offset(c->mc, je_pos + 2, else_pos);
        
        if (n->extra) compile_node(c, n->extra);
        
        int end_pos = c->mc->size;
        patch_jump_offset(c->mc, jmp_pos + 1, end_pos);
    }
}

// === WHILE LOOP ===
static void compile_while(Compiler* c, ASTNode* n) {
    static int lbl = 0;
    int id = lbl++;
    
    if (c->mode == OUT_C) {
        indent(c); emit(c, "while ("); compile_expr(c, n->left); emit(c, ") {\n");
        c->indent++;
        compile_node(c, n->right);
        c->indent--;
        indent(c); emit(c, "}\n");
    }
    else if (c->mode == OUT_ASM) {
        emit(c, ".Lw%d:\n", id);
        compile_expr(c, n->left);
        emit(c, "    cmp rax,0\n    je .Lwe%d\n", id);
        compile_node(c, n->right);
        emit(c, "    jmp .Lw%d\n.Lwe%d:\n", id, id);
    }
    else if (c->mc) {
        int start_pos = c->mc->size;
        
        compile_expr(c, n->left);
        encode_cmp_rax_zero(c->mc);
        
        int je_pos = c->mc->size;
        encode_je_rel32(c->mc, 0);  // placeholder
        
        compile_node(c, n->right);
        
        int jmp_pos = c->mc->size;
        encode_jmp_rel32(c->mc, 0);  // placeholder
        patch_jump_offset(c->mc, jmp_pos + 1, start_pos);
        
        int end_pos = c->mc->size;
        patch_jump_offset(c->mc, je_pos + 2, end_pos);
    }
}

// === FOR LOOP ===
static void compile_for(Compiler* c, ASTNode* n) {
    static int lbl = 0;
    int id = lbl++;
    
    if (c->mode == OUT_C) {
        indent(c); emit(c, "for (");
        if (n->left) compile_expr(c, n->left);
        emit(c, "; ");
        if (n->extra && n->extra->left) compile_expr(c, n->extra->left);
        emit(c, "; ");
        if (n->extra && n->extra->right) compile_expr(c, n->extra->right);
        emit(c, ") {\n");
        c->indent++;
        compile_node(c, n->right);
        c->indent--;
        indent(c); emit(c, "}\n");
    }
    else if (c->mode == OUT_ASM) {
        if (n->left) compile_node(c, n->left);
        emit(c, ".Lf%d:\n", id);
        if (n->extra && n->extra->left) {
            compile_expr(c, n->extra->left);
            emit(c, "    cmp rax,0\n    je .Lfe%d\n", id);
        }
        compile_node(c, n->right);
        if (n->extra && n->extra->right) compile_node(c, n->extra->right);
        emit(c, "    jmp .Lf%d\n.Lfe%d:\n", id, id);
    }
    else if (c->mc) {
        if (n->left) compile_node(c, n->left);
        
        int start_pos = c->mc->size;
        
        int je_pos = -1;
        if (n->extra && n->extra->left) {
            compile_expr(c, n->extra->left);
            encode_cmp_rax_zero(c->mc);
            je_pos = c->mc->size;
            encode_je_rel32(c->mc, 0);
        }
        
        compile_node(c, n->right);
        
        if (n->extra && n->extra->right) compile_node(c, n->extra->right);
        
        int jmp_pos = c->mc->size;
        encode_jmp_rel32(c->mc, 0);
        patch_jump_offset(c->mc, jmp_pos + 1, start_pos);
        
        if (je_pos >= 0) {
            int end_pos = c->mc->size;
            patch_jump_offset(c->mc, je_pos + 2, end_pos);
        }
    }
}

// === RETURN ===
static void compile_return(Compiler* c, ASTNode* n) {
    if (c->mode == OUT_C) {
        indent(c); emit(c, "return ");
        if (n->left) compile_expr(c, n->left);
        else emit(c, "0");
        emit(c, ";\n");
    }
    else if (c->mode == OUT_ASM) {
        if (n->left) compile_expr(c, n->left);
        else emit(c, "    xor rax,rax\n");
        emit(c, "    leave\n    ret\n");
    }
    else if (c->mc) {
        if (n->left) compile_expr(c, n->left);
        else encode_xor_rax_rax(c->mc);
        encode_leave(c->mc);
        encode_ret(c->mc);
    }
}

// === FUNCTION DECLARATION ===
static void compile_func(Compiler* c, ASTNode* n) {
    const char* name = n->value ? n->value : "func";
    ASTNode* param = n->left;  // Parameters are stored in left child

    // Save old variable state for function scope
    int old_nvar = c->nvar;
    int old_stack_off = c->stack_off;
    c->in_function = 1;

    if (c->mode == OUT_C) {
        emit(c, "int %s(", name);
        // Emit parameters
        param = n->left;
        int first = 1;
        while (param) {
            if (!first) emit(c, ", ");
            emit(c, "int %s", param->value);
            first = 0;
            param = param->right;
        }
        emit(c, ") {\n");
        c->indent++;

        // Add parameters as variables
        param = n->left;
        while (param) {
            add_var(c, param->value, 0);
            param = param->right;
        }

        compile_node(c, n->right);
        c->indent--;
        emit(c, "    return 0;\n}\n\n");
    }
    else if (c->mode == OUT_ASM) {
        emit(c, "%s:\n    push rbp\n    mov rbp,rsp\n    sub rsp,256\n", name);

        // System V ABI: Save parameters from registers to stack
        // rdi, rsi, rdx, rcx, r8, r9
        const char* arg_regs[] = {"rdi", "rsi", "rdx", "rcx", "r8", "r9"};
        param = n->left;
        int param_idx = 0;
        while (param && param_idx < 6) {
            int off = -(8 * (param_idx + 1));
            emit(c, "    mov [rbp%+d], %s\n", off, arg_regs[param_idx]);
            add_var(c, param->value, 0);
            param_idx++;
            param = param->right;
        }

        compile_node(c, n->right);
        emit(c, "    xor rax,rax\n    leave\n    ret\n\n");
    }
    else if (c->mc) {
        // Register function in the table
        int func_idx = add_func(c, name, c->mc->size);

        // Function prologue
        encode_push_rbp(c->mc);
        encode_mov_rbp_rsp(c->mc);
        encode_sub_rsp_imm8(c->mc, 128);

        // System V ABI: Save parameters from registers to stack
        // rdi=arg0, rsi=arg1, rdx=arg2, rcx=arg3
        param = n->left;
        int param_idx = 0;
        while (param && param_idx < 6) {
            int off = -(8 * (param_idx + 1));

            // Move argument register to stack
            // For first 4 args: rdi, rsi, rdx, rcx
            if (param_idx == 0) {
                // mov [rbp+off], rdi
                uint8_t code[] = {0x48, 0x89, 0xBD};
                append_bytes(c->mc, code, 3);
                append_bytes(c->mc, (uint8_t*)&off, 4);
            } else if (param_idx == 1) {
                // mov [rbp+off], rsi
                uint8_t code[] = {0x48, 0x89, 0xB5};
                append_bytes(c->mc, code, 3);
                append_bytes(c->mc, (uint8_t*)&off, 4);
            } else if (param_idx == 2) {
                // mov [rbp+off], rdx
                uint8_t code[] = {0x48, 0x89, 0x95};
                append_bytes(c->mc, code, 3);
                append_bytes(c->mc, (uint8_t*)&off, 4);
            } else if (param_idx == 3) {
                // mov [rbp+off], rcx
                uint8_t code[] = {0x48, 0x89, 0x8D};
                append_bytes(c->mc, code, 3);
                append_bytes(c->mc, (uint8_t*)&off, 4);
            }
            // r8 and r9 need REX.B prefix - add if needed for >4 params

            add_var(c, param->value, 0);
            add_func_param(c, func_idx, param->value);
            param_idx++;
            param = param->right;
        }

        compile_node(c, n->right);
        encode_xor_rax_rax(c->mc);
        encode_leave(c->mc);
        encode_ret(c->mc);
    }

    // Restore variable state (exit function scope)
    c->nvar = old_nvar;
    c->stack_off = old_stack_off;
    c->in_function = 0;
}

// === NODE DISPATCHER ===
static void compile_node(Compiler* c, ASTNode* n) {
    while (n) {
        switch (n->type) {
            case PROGRAM_NODE: compile_node(c, n->left); break;
            case FN_CALL_NODE:
                if (c->mode == OUT_C) indent(c);  // Add indent for statement context
                compile_call(c, n);
                // Add semicolon for statement context in C mode
                if (c->mode == OUT_C) emit(c, ";\n");
                break;
            case FN_DECL_NODE: case FN_DECL_SPANISH_NODE: compile_func(c, n); break;
            case VAR_DECL_NODE: compile_var(c, n, 0); break;
            case VAR_DECL_SPANISH_NODE: compile_var(c, n, 1); break;
            case ASSIGN_NODE: compile_assign(c, n); break;
            case IF_NODE: case IF_SPANISH_NODE: compile_if(c, n); break;
            case WHILE_NODE: case WHILE_SPANISH_NODE: compile_while(c, n); break;
            case FOR_NODE: case FOR_SPANISH_NODE: compile_for(c, n); break;
            case RETURN_NODE: compile_return(c, n); break;
            case BREAK_NODE:
                if (c->mode == OUT_C) { indent(c); emit(c, "break;\n"); }
                break;
            case CONTINUE_NODE:
                if (c->mode == OUT_C) { indent(c); emit(c, "continue;\n"); }
                break;
            default: break;
        }
        n = n->next;  // Use next for statement chaining
    }
}

// Helper to check if node is a function declaration
static int is_func_decl(ASTNode* n) {
    return n && (n->type == FN_DECL_NODE || n->type == FN_DECL_SPANISH_NODE);
}

// Compile functions first (before main)
static void compile_functions(Compiler* c, ASTNode* ast) {
    if (!ast) return;
    if (ast->type == PROGRAM_NODE) {
        ASTNode* n = ast->left;
        while (n) {
            if (is_func_decl(n)) {
                compile_func(c, n);
            }
            n = n->next;  // Use next for statement chain
        }
    }
}

// Compile non-function statements (inside main)
static void compile_statements(Compiler* c, ASTNode* ast) {
    if (!ast) return;
    if (ast->type == PROGRAM_NODE) {
        ASTNode* n = ast->left;
        while (n) {
            if (!is_func_decl(n)) {
                // Temporarily stop next-chain traversal since we're iterating manually
                ASTNode* save_next = n->next;
                n->next = NULL;
                compile_node(c, n);
                n->next = save_next;
            }
            n = n->next;  // Use next for statement chain
        }
    } else {
        compile_node(c, ast);
    }
}

// === MAIN WRAPPER ===
static void compile_main(Compiler* c, ASTNode* ast) {
    // First pass: compile all function declarations
    compile_functions(c, ast);

    // Then wrap non-function statements in main
    if (c->mode == OUT_C) {
        emit(c, "int main() {\n");
        c->indent = 1;
    } else if (c->mode == OUT_ASM) {
        // Strings written later
    } else if (c->mc) {
        // Register main function
        add_func(c, "main", c->mc->size);
        encode_push_rbp(c->mc);
        encode_mov_rbp_rsp(c->mc);
        encode_sub_rsp_imm8(c->mc, 128);
    }

    // Compile non-function statements
    compile_statements(c, ast);

    if (c->mode == OUT_C) {
        emit(c, "    return 0;\n}\n");
    } else if (c->mode == OUT_ASM) {
        emit(c, "main:\n    push rbp\n    mov rbp,rsp\n    sub rsp,256\n");
        // Code already in buffer, append ending
        emit(c, "    xor rax,rax\n    leave\n    ret\n");
    } else if (c->mc) {
        encode_xor_rax_rax(c->mc);
        encode_leave(c->mc);
        encode_ret(c->mc);
    }
}

// === PUBLIC API ===
int compile_viva_to_c(const char* code, const char* outfile) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_C);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}

int compile_viva_to_asm(const char* code, const char* outfile) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_ASM);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}

int compile_viva_to_elf(const char* code, const char* outfile) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_ELF);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    c->plat = PLATFORM_LINUX;
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}

int compile_viva_to_platform(const char* code, const char* outfile, PlatformTarget plat) {
    TokenStream* t = tokenize(code);
    ASTNode* ast = parse_program(t);
    Compiler* c = init_compiler(outfile, OUT_ELF);
    if (!c) { free_token_stream(t); free_ast_node(ast); return -1; }
    c->plat = plat;
    if (ast) compile_main(c, ast);
    finish_compiler(c);
    free_token_stream(t);
    free_ast_node(ast);
    return 0;
}
