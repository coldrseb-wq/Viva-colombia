// Viva Bootstrap Compiler
// A self-contained compiler written in Viva that compiles Viva to x86-64 ELF

// ============================================================
// LEXER
// ============================================================

decreto src: [131072]octeto;
decreto src_len: entero = 0;
decreto pos: entero = 0;
decreto tok_type: entero = 0;
decreto tok_buf: [256]octeto;
decreto tok_len: entero = 0;
decreto tok_int_val: entero = 0;

// Token types
// 0=EOF, 1=ID, 2=NUM, 3=STR, 4=(, 5=), 6={, 7=}, 8=;, 9=:, 10=,
// 11=+, 12=-, 13=*, 14=/, 15==, 16===, 17=<, 18=>, 19=[, 20=]
// 21=!=, 22=<=, 23=>=

// String literal data storage - sized for self-hosting (compiler has many strings)
decreto str_lit_data: [32768]octeto;
decreto str_lit_offsets: [256]entero;
decreto str_lit_lens: [256]entero;
decreto str_lit_count: entero = 0;
decreto str_lit_pos: entero = 0;
decreto tok_str_idx: entero = 0;

cancion es_espacio(c: entero): entero {
    si (c == 32) { retorno 1; }
    si (c == 9) { retorno 1; }
    si (c == 10) { retorno 1; }
    si (c == 13) { retorno 1; }
    retorno 0;
}

cancion es_digito(c: entero): entero {
    si (c >= 48) {
        si (c <= 57) { retorno 1; }
    }
    retorno 0;
}

cancion es_letra(c: entero): entero {
    si (c >= 65) {
        si (c <= 90) { retorno 1; }
    }
    si (c >= 97) {
        si (c <= 122) { retorno 1; }
    }
    si (c == 95) { retorno 1; }
    retorno 0;
}

cancion saltar_espacios() {
    mientras (pos < src_len) {
        decreto c: entero = src[pos];
        si (c == 47) {
            si (pos + 1 < src_len) {
                si (src[pos + 1] == 47) {
                    pos = pos + 2;
                    mientras (pos < src_len) {
                        si (src[pos] == 10) {
                            pos = pos + 1;
                            retorno;
                        }
                        pos = pos + 1;
                    }
                    retorno;
                }
            }
        }
        si (es_espacio(c) == 0) { retorno; }
        pos = pos + 1;
    }
}

cancion leer_identificador() {
    tok_len = 0;
    mientras (pos < src_len) {
        decreto c: entero = src[pos];
        si (es_letra(c) == 1) {
            tok_buf[tok_len] = c;
            tok_len = tok_len + 1;
            pos = pos + 1;
        } sino {
            si (es_digito(c) == 1) {
                tok_buf[tok_len] = c;
                tok_len = tok_len + 1;
                pos = pos + 1;
            } sino {
                tok_buf[tok_len] = 0;
                retorno;
            }
        }
    }
    tok_buf[tok_len] = 0;
}

cancion leer_numero() {
    tok_len = 0;
    tok_int_val = 0;
    mientras (pos < src_len) {
        decreto c: entero = src[pos];
        si (es_digito(c) == 1) {
            tok_buf[tok_len] = c;
            tok_int_val = tok_int_val * 10 + c - 48;
            tok_len = tok_len + 1;
            pos = pos + 1;
        } sino {
            tok_buf[tok_len] = 0;
            retorno;
        }
    }
    tok_buf[tok_len] = 0;
}

cancion leer_cadena() {
    // Read string literal (pos is at opening quote)
    pos = pos + 1;  // skip opening "
    decreto start: entero = str_lit_pos;
    tok_len = 0;
    mientras (pos < src_len) {
        // Bounds check - prevent buffer overflow (32768 bytes, 256 entries)
        si (str_lit_pos >= 32000) { retorno; }
        si (str_lit_count >= 250) { retorno; }

        decreto c: entero = src[pos];
        si (c == 34) {
            // Closing quote
            pos = pos + 1;
            str_lit_offsets[str_lit_count] = start;
            str_lit_lens[str_lit_count] = tok_len;
            tok_str_idx = str_lit_count;
            str_lit_count = str_lit_count + 1;
            retorno;
        }
        // Null byte in string = unterminated, stop
        si (c == 0) {
            str_lit_offsets[str_lit_count] = start;
            str_lit_lens[str_lit_count] = tok_len;
            tok_str_idx = str_lit_count;
            str_lit_count = str_lit_count + 1;
            retorno;
        }
        si (c == 92) {
            // Escape sequence
            pos = pos + 1;
            si (pos < src_len) {
                decreto e: entero = src[pos];
                si (e == 110) {
                    // \n -> newline
                    str_lit_data[str_lit_pos] = 10;
                } sino {
                    si (e == 116) {
                        // \t -> tab
                        str_lit_data[str_lit_pos] = 9;
                    } sino {
                        si (e == 34) {
                            // \" -> quote
                            str_lit_data[str_lit_pos] = 34;
                        } sino {
                            si (e == 92) {
                                // \\ -> backslash
                                str_lit_data[str_lit_pos] = 92;
                            } sino {
                                str_lit_data[str_lit_pos] = e;
                            }
                        }
                    }
                }
            }
        } sino {
            str_lit_data[str_lit_pos] = c;
        }
        str_lit_pos = str_lit_pos + 1;
        tok_len = tok_len + 1;
        pos = pos + 1;
    }
    // Unterminated string - store what we have
    str_lit_offsets[str_lit_count] = start;
    str_lit_lens[str_lit_count] = tok_len;
    tok_str_idx = str_lit_count;
    str_lit_count = str_lit_count + 1;
}

cancion siguiente_token() {
    saltar_espacios();
    si (pos >= src_len) { tok_type = 0; retorno; }
    decreto c: entero = src[pos];

    // Null byte = EOF (avoids recursive stack overflow on empty buffer)
    si (c == 0) { tok_type = 0; retorno; }

    si (c == 40) { tok_type = 4; pos = pos + 1; retorno; }
    si (c == 41) { tok_type = 5; pos = pos + 1; retorno; }
    si (c == 123) { tok_type = 6; pos = pos + 1; retorno; }
    si (c == 125) { tok_type = 7; pos = pos + 1; retorno; }
    si (c == 59) { tok_type = 8; pos = pos + 1; retorno; }
    si (c == 58) { tok_type = 9; pos = pos + 1; retorno; }
    si (c == 44) { tok_type = 10; pos = pos + 1; retorno; }
    si (c == 43) { tok_type = 11; pos = pos + 1; retorno; }
    si (c == 45) { tok_type = 12; pos = pos + 1; retorno; }
    si (c == 42) { tok_type = 13; pos = pos + 1; retorno; }
    si (c == 47) { tok_type = 14; pos = pos + 1; retorno; }
    si (c == 91) { tok_type = 19; pos = pos + 1; retorno; }
    si (c == 93) { tok_type = 20; pos = pos + 1; retorno; }

    // String literal
    si (c == 34) {
        leer_cadena();
        tok_type = 3;
        retorno;
    }

    // < or <=
    si (c == 60) {
        pos = pos + 1;
        si (pos < src_len) {
            si (src[pos] == 61) {
                tok_type = 22;  // <=
                pos = pos + 1;
                retorno;
            }
        }
        tok_type = 17;  // <
        retorno;
    }

    // > or >=
    si (c == 62) {
        pos = pos + 1;
        si (pos < src_len) {
            si (src[pos] == 61) {
                tok_type = 23;  // >=
                pos = pos + 1;
                retorno;
            }
        }
        tok_type = 18;  // >
        retorno;
    }

    // = or ==
    si (c == 61) {
        pos = pos + 1;
        si (pos < src_len) {
            si (src[pos] == 61) {
                tok_type = 16;  // ==
                pos = pos + 1;
                retorno;
            }
        }
        tok_type = 15;  // =
        retorno;
    }

    // ! or !=
    si (c == 33) {
        pos = pos + 1;
        si (pos < src_len) {
            si (src[pos] == 61) {
                tok_type = 21;  // !=
                pos = pos + 1;
                retorno;
            }
        }
        // Just ! (not operator) - treat as token type 24 (unary not)
        tok_type = 24;
        retorno;
    }

    si (es_letra(c) == 1) { leer_identificador(); tok_type = 1; retorno; }
    si (es_digito(c) == 1) { leer_numero(); tok_type = 2; retorno; }

    // Unknown character - skip it without recursion to prevent stack overflow
    pos = pos + 1;
    tok_type = 25;  // Unknown token type
}

// ============================================================
// KEYWORD DETECTION
// ============================================================

cancion is_kw_cancion(): entero {
    si (tok_len != 7) { retorno 0; }
    si (tok_buf[0] != 99) { retorno 0; }
    si (tok_buf[1] != 97) { retorno 0; }
    si (tok_buf[2] != 110) { retorno 0; }
    si (tok_buf[3] != 99) { retorno 0; }
    si (tok_buf[4] != 105) { retorno 0; }
    si (tok_buf[5] != 111) { retorno 0; }
    si (tok_buf[6] != 110) { retorno 0; }
    retorno 1;
}

cancion is_kw_retorno(): entero {
    si (tok_len != 7) { retorno 0; }
    si (tok_buf[0] != 114) { retorno 0; }
    si (tok_buf[1] != 101) { retorno 0; }
    si (tok_buf[2] != 116) { retorno 0; }
    si (tok_buf[3] != 111) { retorno 0; }
    si (tok_buf[4] != 114) { retorno 0; }
    si (tok_buf[5] != 110) { retorno 0; }
    si (tok_buf[6] != 111) { retorno 0; }
    retorno 1;
}

cancion is_kw_salir_sys(): entero {
    si (tok_len != 9) { retorno 0; }
    si (tok_buf[0] != 115) { retorno 0; }  // s
    si (tok_buf[1] != 97) { retorno 0; }   // a
    si (tok_buf[2] != 108) { retorno 0; }  // l
    si (tok_buf[3] != 105) { retorno 0; }  // i
    si (tok_buf[4] != 114) { retorno 0; }  // r
    si (tok_buf[5] != 95) { retorno 0; }   // _
    si (tok_buf[6] != 115) { retorno 0; }  // s
    si (tok_buf[7] != 121) { retorno 0; }  // y
    si (tok_buf[8] != 115) { retorno 0; }  // s
    retorno 1;
}

cancion is_kw_escribir_sys(): entero {
    si (tok_len != 12) { retorno 0; }
    si (tok_buf[0] != 101) { retorno 0; }  // e
    si (tok_buf[1] != 115) { retorno 0; }  // s
    si (tok_buf[2] != 99) { retorno 0; }   // c
    si (tok_buf[3] != 114) { retorno 0; }  // r
    si (tok_buf[4] != 105) { retorno 0; }  // i
    si (tok_buf[5] != 98) { retorno 0; }   // b
    si (tok_buf[6] != 105) { retorno 0; }  // i
    si (tok_buf[7] != 114) { retorno 0; }  // r
    si (tok_buf[8] != 95) { retorno 0; }   // _
    si (tok_buf[9] != 115) { retorno 0; }  // s
    si (tok_buf[10] != 121) { retorno 0; } // y
    si (tok_buf[11] != 115) { retorno 0; } // s
    retorno 1;
}

cancion is_kw_leer_sys(): entero {
    si (tok_len != 8) { retorno 0; }
    si (tok_buf[0] != 108) { retorno 0; }  // l
    si (tok_buf[1] != 101) { retorno 0; }  // e
    si (tok_buf[2] != 101) { retorno 0; }  // e
    si (tok_buf[3] != 114) { retorno 0; }  // r
    si (tok_buf[4] != 95) { retorno 0; }   // _
    si (tok_buf[5] != 115) { retorno 0; }  // s
    si (tok_buf[6] != 121) { retorno 0; }  // y
    si (tok_buf[7] != 115) { retorno 0; }  // s
    retorno 1;
}

cancion is_kw_entero(): entero {
    si (tok_len != 6) { retorno 0; }
    si (tok_buf[0] != 101) { retorno 0; }  // e
    si (tok_buf[1] != 110) { retorno 0; }  // n
    si (tok_buf[2] != 116) { retorno 0; }  // t
    si (tok_buf[3] != 101) { retorno 0; }  // e
    si (tok_buf[4] != 114) { retorno 0; }  // r
    si (tok_buf[5] != 111) { retorno 0; }  // o
    retorno 1;
}

cancion is_kw_octeto(): entero {
    si (tok_len != 6) { retorno 0; }
    si (tok_buf[0] != 111) { retorno 0; }  // o
    si (tok_buf[1] != 99) { retorno 0; }   // c
    si (tok_buf[2] != 116) { retorno 0; }  // t
    si (tok_buf[3] != 101) { retorno 0; }  // e
    si (tok_buf[4] != 116) { retorno 0; }  // t
    si (tok_buf[5] != 111) { retorno 0; }  // o
    retorno 1;
}

cancion is_kw_decreto(): entero {
    si (tok_len != 7) { retorno 0; }
    si (tok_buf[0] != 100) { retorno 0; }
    si (tok_buf[1] != 101) { retorno 0; }
    si (tok_buf[2] != 99) { retorno 0; }
    si (tok_buf[3] != 114) { retorno 0; }
    si (tok_buf[4] != 101) { retorno 0; }
    si (tok_buf[5] != 116) { retorno 0; }
    si (tok_buf[6] != 111) { retorno 0; }
    retorno 1;
}

cancion is_kw_si(): entero {
    si (tok_len != 2) { retorno 0; }
    si (tok_buf[0] != 115) { retorno 0; }
    si (tok_buf[1] != 105) { retorno 0; }
    retorno 1;
}

cancion is_kw_mientras(): entero {
    si (tok_len != 8) { retorno 0; }
    si (tok_buf[0] != 109) { retorno 0; }
    si (tok_buf[1] != 105) { retorno 0; }
    si (tok_buf[2] != 101) { retorno 0; }
    si (tok_buf[3] != 110) { retorno 0; }
    si (tok_buf[4] != 116) { retorno 0; }
    si (tok_buf[5] != 114) { retorno 0; }
    si (tok_buf[6] != 97) { retorno 0; }
    si (tok_buf[7] != 115) { retorno 0; }
    retorno 1;
}

cancion is_kw_sino(): entero {
    si (tok_len != 4) { retorno 0; }
    si (tok_buf[0] != 115) { retorno 0; }  // s
    si (tok_buf[1] != 105) { retorno 0; }  // i
    si (tok_buf[2] != 110) { retorno 0; }  // n
    si (tok_buf[3] != 111) { retorno 0; }  // o
    retorno 1;
}

// Symbol table for local variables
decreto sym_names: [512]octeto;
decreto sym_offs: [32]entero;
decreto sym_sizes: [32]entero;
decreto sym_elem_sizes: [32]entero;  // Element size: 1 for octeto, 8 for entero
decreto sym_cnt: entero = 0;
decreto sym_np: entero = 0;
decreto sym_sp: entero = 0;

// Global storage for loop addresses (to avoid local var issues)
decreto g_loop_start: entero = 0;
decreto g_je_addr: entero = 0;
decreto g_assign_off: entero = 0;
decreto g_arr_elem_sz: entero = 1;  // Element size for current array access

// Function table for tracking function addresses - sized for self-hosting
decreto fn_names: [4096]octeto;
decreto fn_addrs: [256]entero;
decreto fn_cnt: entero = 0;
decreto fn_np: entero = 0;
decreto main_addr: entero = 0;  // Entry point (address of main function)
decreto entry_patch_addr: entero = 0;  // Address to patch for entry stub call

// Forward reference patches (calls to not-yet-defined functions)
decreto patch_addrs: [512]entero;    // Code addresses to patch
decreto patch_names: [8192]octeto;   // Names of functions to patch (null-separated)
decreto patch_name_lens: [512]entero; // Length of each patch function name
decreto patch_name_starts: [512]entero; // Start position in patch_names for each patch
decreto patch_cnt: entero = 0;
decreto patch_np: entero = 0;

// Temporary storage for function name being called
decreto call_name: [64]octeto;
decreto call_name_len: entero = 0;

cancion add_patch(addr: entero) {
    // Save a forward reference patch using call_name
    patch_addrs[patch_cnt] = addr;
    patch_name_starts[patch_cnt] = patch_np;
    patch_name_lens[patch_cnt] = call_name_len;
    decreto i: entero = 0;
    mientras (i < call_name_len) {
        patch_names[patch_np] = call_name[i];
        patch_np = patch_np + 1;
        i = i + 1;
    }
    patch_names[patch_np] = 0;
    patch_np = patch_np + 1;
    patch_cnt = patch_cnt + 1;
}

cancion resolve_patches() {
    // After all functions are compiled, resolve forward references
    decreto p: entero = 0;
    mientras (p < patch_cnt) {
        // Find the function by name
        decreto ps: entero = patch_name_starts[p];
        decreto pl: entero = patch_name_lens[p];
        decreto fn_idx: entero = 0;
        decreto fn_p: entero = 0;
        decreto found: entero = 0;
        mientras (fn_idx < fn_cnt) {
            decreto j: entero = 0;
            decreto ok: entero = 1;
            mientras (fn_names[fn_p + j] != 0) {
                si (j >= pl) { ok = 0; }
                si (ok == 1) {
                    si (patch_names[ps + j] != fn_names[fn_p + j]) { ok = 0; }
                }
                j = j + 1;
            }
            si (ok == 1) {
                si (j == pl) {
                    // Found the function
                    decreto target: entero = fn_addrs[fn_idx];
                    decreto addr: entero = patch_addrs[p];
                    decreto rel: entero = target - addr - 4;
                    // Patch the 4-byte offset at addr
                    code[addr] = rel;
                    si (rel < 0) {
                        // Handle negative offsets (two's complement)
                        decreto u: entero = rel + 4294967296;
                        code[addr] = u;
                        code[addr + 1] = u / 256;
                        code[addr + 2] = u / 65536;
                        code[addr + 3] = u / 16777216;
                    } sino {
                        code[addr] = rel;
                        code[addr + 1] = rel / 256;
                        code[addr + 2] = rel / 65536;
                        code[addr + 3] = rel / 16777216;
                    }
                    found = 1;
                }
            }
            mientras (fn_names[fn_p] != 0) { fn_p = fn_p + 1; }
            fn_p = fn_p + 1;
            fn_idx = fn_idx + 1;
        }
        p = p + 1;
    }
}

cancion fn_add() {
    // Add current function (tok_buf) to function table with address code_pos
    decreto i: entero = 0;
    mientras (i < tok_len) {
        fn_names[fn_np] = tok_buf[i];
        fn_np = fn_np + 1;
        i = i + 1;
    }
    fn_names[fn_np] = 0;
    fn_np = fn_np + 1;
    fn_addrs[fn_cnt] = code_pos;

    // Check if this is "main" or "principal" - set entry point
    // "main" = 109, 97, 105, 110
    // "principal" = 112, 114, 105, 110, 99, 105, 112, 97, 108
    decreto is_main: entero = 0;
    si (tok_len == 4) {
        si (tok_buf[0] == 109) {
            si (tok_buf[1] == 97) {
                si (tok_buf[2] == 105) {
                    si (tok_buf[3] == 110) {
                        is_main = 1;
                    }
                }
            }
        }
    }
    // Check for "principal" (9 chars)
    si (tok_len == 9) {
        si (tok_buf[0] == 112) {
            si (tok_buf[1] == 114) {
                si (tok_buf[2] == 105) {
                    si (tok_buf[3] == 110) {
                        si (tok_buf[4] == 99) {
                            si (tok_buf[5] == 105) {
                                si (tok_buf[6] == 112) {
                                    si (tok_buf[7] == 97) {
                                        si (tok_buf[8] == 108) {
                                            is_main = 1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    si (is_main == 1) {
        main_addr = code_pos;
    }

    fn_cnt = fn_cnt + 1;
}

cancion fn_find(): entero {
    // Find function by name in call_name, return address+1 (0 means not found)
    decreto i: entero = 0;
    decreto p: entero = 0;
    mientras (i < fn_cnt) {
        decreto j: entero = 0;
        decreto ok: entero = 1;
        mientras (fn_names[p + j] != 0) {
            si (j >= call_name_len) { ok = 0; }
            si (ok == 1) {
                si (call_name[j] != fn_names[p + j]) { ok = 0; }
            }
            j = j + 1;
        }
        si (ok == 1) {
            si (j == call_name_len) { retorno fn_addrs[i] + 1; }
        }
        mientras (fn_names[p] != 0) { p = p + 1; }
        p = p + 1;
        i = i + 1;
    }
    retorno 0;
}

cancion save_call_name() {
    // Copy tok_buf to call_name for later lookup
    decreto i: entero = 0;
    mientras (i < tok_len) {
        call_name[i] = tok_buf[i];
        i = i + 1;
    }
    call_name_len = tok_len;
}

cancion sym_reset() {
    sym_cnt = 0;
    sym_np = 0;
    sym_sp = 0;
}

cancion sym_add(): entero {
    decreto i: entero = 0;
    mientras (i < tok_len) {
        sym_names[sym_np] = tok_buf[i];
        sym_np = sym_np + 1;
        i = i + 1;
    }
    sym_names[sym_np] = 0;
    sym_np = sym_np + 1;
    sym_sp = sym_sp - 8;
    sym_offs[sym_cnt] = sym_sp;
    sym_sizes[sym_cnt] = 8;  // Scalar (8 bytes)
    sym_cnt = sym_cnt + 1;
    retorno sym_sp;
}

cancion sym_add_size(size: entero): entero {
    // Add symbol with custom size (for arrays)
    decreto i: entero = 0;
    mientras (i < tok_len) {
        sym_names[sym_np] = tok_buf[i];
        sym_np = sym_np + 1;
        i = i + 1;
    }
    sym_names[sym_np] = 0;
    sym_np = sym_np + 1;
    sym_sp = sym_sp - size;
    sym_offs[sym_cnt] = sym_sp;
    sym_sizes[sym_cnt] = size;  // Track actual size
    sym_cnt = sym_cnt + 1;
    retorno sym_sp;
}

decreto g_sym_idx: entero = 0;  // Index of last found local (for array check)

cancion sym_find(): entero {
    decreto i: entero = 0;
    decreto p: entero = 0;
    mientras (i < sym_cnt) {
        decreto j: entero = 0;
        decreto ok: entero = 1;
        mientras (sym_names[p + j] != 0) {
            si (j >= tok_len) { ok = 0; }
            si (ok == 1) {
                si (tok_buf[j] != sym_names[p + j]) { ok = 0; }
            }
            j = j + 1;
        }
        si (ok == 1) {
            si (j == tok_len) {
                g_sym_idx = i;
                retorno sym_offs[i];
            }
        }
        mientras (sym_names[p] != 0) { p = p + 1; }
        p = p + 1;
        i = i + 1;
    }
    retorno 0;
}

cancion sym_is_array(): entero {
    // Check if last found local (via g_sym_idx) is an array (size > 8)
    si (g_sym_idx >= sym_cnt) { retorno 0; }  // Bounds check
    si (sym_sizes[g_sym_idx] > 8) { retorno 1; }
    retorno 0;
}

cancion sym_elem_size(): entero {
    // Get element size of last found local (via g_sym_idx)
    si (g_sym_idx >= sym_cnt) { retorno 1; }  // Default to byte
    retorno sym_elem_sizes[g_sym_idx];
}

// ============================================================
// CODE GENERATOR
// ============================================================

// Code and data buffers - sized for self-hosting (compiler generates ~50KB code)
decreto code: [131072]octeto;
decreto code_pos: entero = 0;
decreto data: [16384]octeto;
decreto data_pos: entero = 0;

cancion emit_byte(b: entero) {
    code[code_pos] = b;
    code_pos = code_pos + 1;
}

cancion emit_dword(d: entero) {
    // Handle negative numbers for two's complement
    decreto u: entero = d;
    si (d < 0) {
        u = d + 4294967296;
    }
    code[code_pos] = u;
    code[code_pos + 1] = u / 256;
    code[code_pos + 2] = u / 65536;
    code[code_pos + 3] = u / 16777216;
    code_pos = code_pos + 4;
}

cancion emit_qword(q: entero) {
    emit_dword(q);
    emit_dword(0);
}

// push rbp
cancion emit_push_rbp() { emit_byte(85); }

// mov rbp, rsp
cancion emit_mov_rbp_rsp() {
    emit_byte(72);
    emit_byte(137);
    emit_byte(229);
}

// leave
cancion emit_leave() { emit_byte(201); }

// ret
cancion emit_ret() { emit_byte(195); }

// mov rax, imm32
cancion emit_mov_rax_imm32(val: entero) {
    emit_byte(72);
    emit_byte(199);
    emit_byte(192);
    emit_dword(val);
}

// mov rdi, rax
cancion emit_mov_rdi_rax() {
    emit_byte(72);
    emit_byte(137);
    emit_byte(199);
}

// mov rsi, rax
cancion emit_mov_rsi_rax() {
    emit_byte(72);
    emit_byte(137);
    emit_byte(198);
}

// mov rdx, rax
cancion emit_mov_rdx_rax() {
    emit_byte(72);
    emit_byte(137);
    emit_byte(194);
}

// xor rax, rax
cancion emit_xor_rax_rax() {
    emit_byte(72);
    emit_byte(49);
    emit_byte(192);
}

// syscall
cancion emit_syscall() {
    emit_byte(15);
    emit_byte(5);
}

// lea rax, [rip+disp32]
cancion emit_lea_rax_rip_rel(disp: entero) {
    emit_byte(72);
    emit_byte(141);
    emit_byte(5);
    emit_dword(disp);
}

// sub rsp, imm32
cancion emit_sub_rsp(v: entero) {
    emit_byte(72);
    emit_byte(129);
    emit_byte(236);
    emit_dword(v);
}

// add rsp, imm32
cancion emit_add_rsp(v: entero) {
    emit_byte(72);
    emit_byte(129);
    emit_byte(196);
    emit_dword(v);
}

// mov rax, [rbp+off]
cancion emit_load(off: entero) {
    emit_byte(72);
    emit_byte(139);
    emit_byte(133);
    emit_dword(off);
}

// mov [rbp+off], rax
cancion emit_store(off: entero) {
    emit_byte(72);
    emit_byte(137);
    emit_byte(133);
    emit_dword(off);
}

// push rax
cancion emit_push() { emit_byte(80); }

// pop rax
cancion emit_pop() { emit_byte(88); }

// pop rcx
cancion emit_pop_rcx() { emit_byte(89); }

// mov rcx, rax
cancion emit_mov_rcx() {
    emit_byte(72);
    emit_byte(137);
    emit_byte(193);
}

// add rax, rcx
cancion emit_add() {
    emit_byte(72);
    emit_byte(1);
    emit_byte(200);
}

// sub rax, rcx
cancion emit_sub() {
    emit_byte(72);
    emit_byte(41);
    emit_byte(200);
}

// imul rax, rcx
cancion emit_mul() {
    emit_byte(72);
    emit_byte(15);
    emit_byte(175);
    emit_byte(193);
}

// cqo; idiv rcx
cancion emit_div() {
    emit_byte(72);
    emit_byte(153);
    emit_byte(72);
    emit_byte(247);
    emit_byte(249);
}

// cmp rax, rcx (for correct ordering: left < right)
cancion emit_cmp() {
    emit_byte(72);
    emit_byte(57);
    emit_byte(200);
}

// sete al; movzx rax, al
cancion emit_sete() {
    emit_byte(15);
    emit_byte(148);
    emit_byte(192);
    emit_byte(72);
    emit_byte(15);
    emit_byte(182);
    emit_byte(192);
}

// setne al; movzx rax, al
cancion emit_setne() {
    emit_byte(15);
    emit_byte(149);
    emit_byte(192);
    emit_byte(72);
    emit_byte(15);
    emit_byte(182);
    emit_byte(192);
}

// setl al; movzx rax, al
cancion emit_setl() {
    emit_byte(15);
    emit_byte(156);
    emit_byte(192);
    emit_byte(72);
    emit_byte(15);
    emit_byte(182);
    emit_byte(192);
}

// setg al; movzx rax, al
cancion emit_setg() {
    emit_byte(15);
    emit_byte(159);
    emit_byte(192);
    emit_byte(72);
    emit_byte(15);
    emit_byte(182);
    emit_byte(192);
}

// test rax, rax
cancion emit_testrax() {
    emit_byte(72);
    emit_byte(133);
    emit_byte(192);
}

// je rel32 (returns patch addr)
cancion emit_je(): entero {
    emit_byte(15);
    emit_byte(132);
    decreto addr: entero = code_pos;
    emit_dword(0);
    retorno addr;
}

// jne rel32 (returns patch addr)
cancion emit_jne(): entero {
    emit_byte(15);
    emit_byte(133);
    decreto addr: entero = code_pos;
    emit_dword(0);
    retorno addr;
}

// jmp rel32 (returns patch addr)
cancion emit_jmp(): entero {
    emit_byte(233);
    decreto addr: entero = code_pos;
    emit_dword(0);
    retorno addr;
}

// Patch a jump target at addr to point to current code_pos
cancion emit_patch(addr: entero) {
    decreto rel: entero = code_pos - addr - 4;
    // Handle negative offsets for backward jumps
    decreto u: entero = rel;
    si (rel < 0) {
        u = rel + 4294967296;
    }
    code[addr] = u;
    code[addr + 1] = u / 256;
    code[addr + 2] = u / 65536;
    code[addr + 3] = u / 16777216;
}

// setle al; movzx rax, al
cancion emit_setle() {
    emit_byte(15);
    emit_byte(158);
    emit_byte(192);
    emit_byte(72);
    emit_byte(15);
    emit_byte(182);
    emit_byte(192);
}

// setge al; movzx rax, al
cancion emit_setge() {
    emit_byte(15);
    emit_byte(157);
    emit_byte(192);
    emit_byte(72);
    emit_byte(15);
    emit_byte(182);
    emit_byte(192);
}

// call rel32 (returns patch addr)
cancion emit_call(): entero {
    emit_byte(232);
    decreto addr: entero = code_pos;
    emit_dword(0);
    retorno addr;
}

// call with relative offset to target address
cancion emit_call_rel(target: entero) {
    emit_byte(232);
    decreto rel: entero = target - code_pos - 4;
    emit_dword(rel);
}

// mov rdi, rax (for first argument)
cancion emit_mov_rdi_from_rax() {
    emit_byte(72);   // REX.W
    emit_byte(137);  // mov r/m64, r64
    emit_byte(199);  // ModRM: rdi <- rax
}

// mov rsi, rax (for second argument)
cancion emit_mov_rsi_from_rax() {
    emit_byte(72);   // REX.W
    emit_byte(137);  // mov r/m64, r64
    emit_byte(198);  // ModRM: rsi <- rax
}

// cmp rax, 0
cancion emit_cmp_rax_0() {
    emit_byte(72);
    emit_byte(131);
    emit_byte(248);
    emit_byte(0);
}

// lea rax, [rbp+off] - get address of local variable/array
cancion emit_lea_rbp_off(off: entero) {
    emit_byte(72);   // REX.W
    emit_byte(141);  // lea
    emit_byte(133);  // ModRM: rax, [rbp+disp32]
    emit_dword(off);
}

// movzx rax, byte [rax] - load byte from address in rax
cancion emit_load_byte_indirect() {
    emit_byte(72);   // REX.W
    emit_byte(15);   // 0F prefix
    emit_byte(182);  // movzx r64, r/m8
    emit_byte(0);    // ModRM: rax, [rax]
}

// mov rax, [rax] - load qword from address in rax
cancion emit_load_qword_indirect() {
    emit_byte(72);   // REX.W
    emit_byte(139);  // mov r64, r/m64
    emit_byte(0);    // ModRM: rax, [rax]
}

// mov [rax], cl - store byte to address in rax
cancion emit_store_byte_indirect() {
    emit_byte(136);  // mov r/m8, r8
    emit_byte(8);    // ModRM: [rax], cl
}

// mov [rax], rcx - store qword to address in rax
cancion emit_store_qword_indirect() {
    emit_byte(72);   // REX.W
    emit_byte(137);  // mov r/m64, r64
    emit_byte(8);    // ModRM: [rax], rcx
}

// shl rax, 3 - multiply rax by 8
cancion emit_shl_rax_3() {
    emit_byte(72);   // REX.W
    emit_byte(193);  // shl r/m64, imm8
    emit_byte(224);  // ModRM: rax
    emit_byte(3);    // shift count = 3
}

// mov rcx, rax (preserving value for store)
cancion emit_mov_rax_to_rcx() {
    emit_byte(72);
    emit_byte(137);
    emit_byte(193);
}

// Load global variable (8-byte value at data_base + offset)
// Uses RIP-relative addressing: mov rax, [rip+disp32]
cancion emit_load_global(off: entero) {
    // Data section at 0x411000, code at 0x401000
    // RIP-relative: target - (rip_after_instruction)
    // target = 0x411000 + off
    // rip_after = 0x401000 + code_pos + 7
    // disp = 0x411000 + off - 0x401000 - code_pos - 7
    //      = 65536 + off - code_pos - 7
    emit_byte(72);   // REX.W
    emit_byte(139);  // mov r64, r/m64
    emit_byte(5);    // ModRM: rax, [rip+disp32]
    decreto disp: entero = 65536 + off - code_pos - 4;
    emit_dword(disp);
}

// Store global variable (8-byte value to data_base + offset)
// Uses RIP-relative addressing: mov [rip+disp32], rax
cancion emit_store_global(off: entero) {
    emit_byte(72);   // REX.W
    emit_byte(137);  // mov r/m64, r64
    emit_byte(5);    // ModRM: [rip+disp32], rax
    decreto disp: entero = 65536 + off - code_pos - 4;
    emit_dword(disp);
}

// Load address of global (for arrays): lea rax, [rip+disp32]
cancion emit_lea_global(off: entero) {
    emit_byte(72);   // REX.W
    emit_byte(141);  // lea
    emit_byte(5);    // ModRM: rax, [rip+disp32]
    decreto disp: entero = 65536 + off - code_pos - 4;
    emit_dword(disp);
}

// Load byte from global (for byte arrays)
cancion emit_load_global_byte(off: entero) {
    emit_lea_global(off);
    emit_load_byte_indirect();
}

// ============================================================
// STRING DATA
// ============================================================

decreto str_data: [4096]octeto;
decreto str_data_pos: entero = 0;

cancion add_string(s: entero, len: entero): entero {
    decreto start: entero = str_data_pos;
    decreto i: entero = 0;
    mientras (i < len) {
        str_data[str_data_pos] = src[s + i];
        str_data_pos = str_data_pos + 1;
        i = i + 1;
    }
    retorno start;
}

// ============================================================
// SIMPLE PARSER + CODE GENERATOR
// ============================================================

// Forward declaration placeholder
decreto parse_depth: entero = 0;

// Global variable lookup - moved here to avoid forward reference issues
decreto g_glob_idx: entero = 0;  // Index of last found global (for checking if array)

cancion glob_find(): entero {
    // Find global variable, return data offset + 1 (0 = not found)
    // Also sets g_glob_idx for use by glob_is_array()
    decreto i: entero = 0;
    decreto p: entero = 0;
    mientras (i < glob_cnt) {
        decreto j: entero = 0;
        decreto ok: entero = 1;
        mientras (glob_names[p + j] != 0) {
            si (j >= tok_len) { ok = 0; }
            si (ok == 1) {
                si (tok_buf[j] != glob_names[p + j]) { ok = 0; }
            }
            j = j + 1;
        }
        si (ok == 1) {
            si (j == tok_len) {
                g_glob_idx = i;
                retorno glob_offs[i] + 1;
            }
        }
        mientras (glob_names[p] != 0) { p = p + 1; }
        p = p + 1;
        i = i + 1;
    }
    retorno 0;
}

cancion glob_is_array(): entero {
    // Check if last found global (via g_glob_idx) is an array
    si (g_glob_idx >= glob_cnt) { retorno 0; }  // Bounds check
    retorno glob_is_arr[g_glob_idx];
}

cancion glob_elem_size(): entero {
    // Get element size of last found global (via g_glob_idx)
    si (g_glob_idx >= glob_cnt) { retorno 1; }  // Default to byte
    retorno glob_elem_sizes[g_glob_idx];
}

// Compile a primary expression (number, variable, function call, or parenthesized)
cancion compile_primary() {
    si (tok_type == 2) {
        // Number literal
        emit_mov_rax_imm32(tok_int_val);
        siguiente_token();
        retorno;
    }
    si (tok_type == 4) {
        // Parenthesized: (expr)
        siguiente_token();  // skip (
        compile_comparison();
        si (tok_type == 5) { siguiente_token(); }  // skip )
        retorno;
    }
    si (tok_type == 1) {
        // Check for leer_sys as expression (syscall that returns a value)
        si (is_kw_leer_sys() == 1) {
            // leer_sys(fd, buf, len) - returns number of bytes read
            siguiente_token();  // skip leer_sys
            si (tok_type == 4) { siguiente_token(); }  // skip (

            // fd (first arg)
            compile_comparison();
            emit_push();  // save fd on stack
            si (tok_type == 10) { siguiente_token(); }  // skip ,

            // buf (second arg) - should be a variable/array
            compile_comparison();
            emit_push();  // save buf on stack
            si (tok_type == 10) { siguiente_token(); }  // skip ,

            // len (third arg)
            compile_comparison();
            emit_mov_rdx_rax();  // rdx = len

            // Set up rsi (buf)
            emit_pop();
            emit_mov_rsi_rax();

            // Set up rdi (fd)
            emit_pop();
            emit_mov_rdi_rax();

            // syscall number
            emit_mov_rax_imm32(0);  // sys_read
            emit_syscall();

            si (tok_type == 5) { siguiente_token(); }  // skip )
            retorno;
        }

        // Identifier - could be variable or function call
        // First check if it's a local variable
        decreto off: entero = sym_find();

        // Check for global variable (before siguiente_token consumes tok_buf)
        decreto goff: entero = 0;
        si (off == 0) { goff = glob_find(); }

        // Save identifier name for potential function call
        save_call_name();
        siguiente_token();  // skip identifier

        // Check if followed by '(' - then it's a function call
        si (tok_type == 4) {
            // Function call: name(args)
            // Look up function BEFORE compiling arguments (args compilation clobbers call_name)
            decreto fn_addr: entero = fn_find();

            siguiente_token();  // skip (

            // Compile arguments - simplified to avoid deep recursion
            si (tok_type != 5) {
                // First argument -> rdi (handle only simple cases)
                si (tok_type == 2) {
                    // Number literal
                    emit_mov_rax_imm32(tok_int_val);
                    siguiente_token();
                } sino {
                    si (tok_type == 1) {
                        // Variable
                        decreto arg_off: entero = sym_find();
                        si (arg_off != 0) {
                            emit_load(arg_off);
                        }
                        siguiente_token();
                    }
                }
                emit_mov_rdi_from_rax();

                si (tok_type == 10) {
                    // Second argument -> rsi
                    siguiente_token();  // skip ,
                    si (tok_type == 2) {
                        emit_mov_rax_imm32(tok_int_val);
                        siguiente_token();
                    } sino {
                        si (tok_type == 1) {
                            decreto arg_off2: entero = sym_find();
                            si (arg_off2 != 0) {
                                emit_load(arg_off2);
                            }
                            siguiente_token();
                        }
                    }
                    emit_mov_rsi_from_rax();
                }
            }
            si (tok_type == 5) { siguiente_token(); }  // skip )

            // Emit call
            si (fn_addr != 0) {
                emit_call_rel(fn_addr - 1);  // -1 because fn_find returns addr+1
            } sino {
                // Forward reference - emit call with 0 offset, save for patching
                decreto patch_addr: entero = emit_call();
                add_patch(patch_addr);
            }
            retorno;
        }

        // Check if followed by '[' - then it's array element access
        si (tok_type == 19) {
            // Array access: name[index]
            siguiente_token();  // skip [

            // Get base address of array into rax (check local then global) and element size
            si (off != 0) {
                emit_lea_rbp_off(off);
                g_arr_elem_sz = sym_elem_size();
            } sino {
                // Use pre-computed goff
                si (goff != 0) {
                    emit_lea_global(goff - 1);
                    g_arr_elem_sz = glob_elem_size();
                } sino {
                    emit_xor_rax_rax();
                    g_arr_elem_sz = 1;
                }
            }
            emit_push();  // save base address

            // Handle index - simplified to avoid recursion
            si (tok_type == 2) {
                // Number literal index
                emit_mov_rax_imm32(tok_int_val);
                siguiente_token();
            } sino {
                si (tok_type == 1) {
                    // Variable index - check local then global
                    decreto idx_off: entero = sym_find();
                    decreto gidx: entero = 0;
                    si (idx_off == 0) { gidx = glob_find(); }
                    siguiente_token();  // consume before using
                    si (idx_off != 0) {
                        emit_load(idx_off);
                    } sino {
                        si (gidx != 0) {
                            emit_load_global(gidx - 1);
                        } sino {
                            emit_xor_rax_rax();
                        }
                    }
                } sino {
                    emit_xor_rax_rax();
                }
            }

            // Scale index by element size (multiply by 8 for entero arrays)
            si (g_arr_elem_sz == 8) {
                emit_shl_rax_3();
            }

            // Now: rax=scaled_index, stack top=base
            emit_pop_rcx();  // rcx = base address
            emit_add();      // rax = base + scaled_index (final address)
            si (g_arr_elem_sz == 8) {
                emit_load_qword_indirect();  // load qword from [rax]
            } sino {
                emit_load_byte_indirect();  // load byte from [rax]
            }

            si (tok_type == 20) { siguiente_token(); }  // skip ]
            retorno;
        }

        // Not a function call or array access - load variable
        // For arrays, load address; for scalars, load value
        si (off != 0) {
            si (sym_is_array() == 1) {
                emit_lea_rbp_off(off);  // Array: load address
            } sino {
                emit_load(off);  // Scalar: load value
            }
        } sino {
            // Use pre-computed goff
            si (goff != 0) {
                si (glob_is_array() == 1) {
                    emit_lea_global(goff - 1);  // Array: load address
                } sino {
                    emit_load_global(goff - 1);  // Scalar: load value
                }
            } sino {
                emit_xor_rax_rax();
            }
        }
        retorno;
    }
    // Default: 0
    emit_xor_rax_rax();
}

// Compile term: primary ((* | /) primary)*
cancion compile_term() {
    compile_primary();
    decreto done: entero = 0;
    mientras (done == 0) {
        si (tok_type == 13) {
            // * multiply
            emit_push();
            siguiente_token();
            compile_primary();
            emit_mov_rcx();
            emit_pop();
            emit_mul();
        } sino {
            si (tok_type == 14) {
                // / divide
                emit_push();
                siguiente_token();
                compile_primary();
                emit_mov_rcx();
                emit_pop();
                emit_div();
            } sino {
                done = 1;
            }
        }
    }
}

// Compile additive: term ((+ | -) term)*
cancion compile_additive() {
    compile_term();
    decreto done: entero = 0;
    mientras (done == 0) {
        si (tok_type == 11) {
            // + add
            emit_push();
            siguiente_token();
            compile_term();
            emit_mov_rcx();
            emit_pop();
            emit_add();
        } sino {
            si (tok_type == 12) {
                // - subtract
                emit_push();
                siguiente_token();
                compile_term();
                emit_mov_rcx();
                emit_pop();
                emit_sub();
            } sino {
                done = 1;
            }
        }
    }
}

// Compile comparison: additive ((<|>|==|!=|<=|>=) additive)?
cancion compile_comparison() {
    compile_additive();
    si (tok_type == 16) {
        // == equal
        emit_push();
        siguiente_token();
        compile_additive();
        emit_mov_rcx();
        emit_pop();
        emit_cmp();
        emit_sete();
        retorno;
    }
    si (tok_type == 21) {
        // != not equal
        emit_push();
        siguiente_token();
        compile_additive();
        emit_mov_rcx();
        emit_pop();
        emit_cmp();
        emit_setne();
        retorno;
    }
    si (tok_type == 17) {
        // < less than
        emit_push();
        siguiente_token();
        compile_additive();
        emit_mov_rcx();
        emit_pop();
        emit_cmp();
        emit_setl();
        retorno;
    }
    si (tok_type == 22) {
        // <= less than or equal
        emit_push();
        siguiente_token();
        compile_additive();
        emit_mov_rcx();
        emit_pop();
        emit_cmp();
        emit_setle();
        retorno;
    }
    si (tok_type == 18) {
        // > greater than
        emit_push();
        siguiente_token();
        compile_additive();
        emit_mov_rcx();
        emit_pop();
        emit_cmp();
        emit_setg();
        retorno;
    }
    si (tok_type == 23) {
        // >= greater than or equal
        emit_push();
        siguiente_token();
        compile_additive();
        emit_mov_rcx();
        emit_pop();
        emit_cmp();
        emit_setge();
        retorno;
    }
}

// Legacy wrapper
cancion compile_expr(): entero {
    si (tok_type == 2) {
        decreto val: entero = tok_int_val;
        siguiente_token();
        retorno val;
    }
    retorno 0;
}

cancion compile_syscall_exit() {
    // salir_sys(code)
    siguiente_token();  // skip salir_sys
    si (tok_type == 4) { siguiente_token(); }  // skip (
    compile_comparison();  // compile expression into rax
    si (tok_type == 5) { siguiente_token(); }  // skip )
    si (tok_type == 8) { siguiente_token(); }  // skip ;

    emit_mov_rdi_rax();
    emit_mov_rax_imm32(60);
    emit_syscall();
}

cancion compile_syscall_write() {
    // escribir_sys(fd, buf, len)
    siguiente_token();  // skip escribir_sys
    si (tok_type == 4) { siguiente_token(); }  // skip (

    // fd (first arg)
    compile_comparison();
    emit_push();  // save fd on stack
    si (tok_type == 10) { siguiente_token(); }  // skip ,

    // buf (second arg) - could be string literal or variable
    decreto str_idx: entero = 0;
    decreto is_str_lit: entero = 0;
    si (tok_type == 3) {
        // String literal - save its index for data section
        str_idx = tok_str_idx;
        is_str_lit = 1;
        siguiente_token();
    } sino {
        // Variable or expression
        compile_comparison();
        emit_push();  // save buf on stack
    }
    si (tok_type == 10) { siguiente_token(); }  // skip ,

    // len (third arg)
    compile_comparison();
    emit_mov_rdx_rax();  // rdx = len

    // Now set up rsi (buf)
    si (is_str_lit == 1) {
        // Load string literal address from data section
        // String literals are after globals, so add glob_data_pos
        decreto str_off: entero = str_lit_offsets[str_idx];
        decreto cur: entero = code_pos;
        decreto rip_rel: entero = 65536 + glob_data_pos + str_off - cur - 7;
        emit_lea_rax_rip_rel(rip_rel);
        emit_mov_rsi_rax();
    } sino {
        emit_pop();  // get buf from stack
        emit_mov_rsi_rax();
    }

    // Set up rdi (fd)
    emit_pop();  // get fd from stack
    emit_mov_rdi_rax();

    // syscall number
    emit_mov_rax_imm32(1);  // sys_write
    emit_syscall();

    si (tok_type == 5) { siguiente_token(); }  // skip )
    si (tok_type == 8) { siguiente_token(); }  // skip ;
}

cancion compile_syscall_read() {
    // leer_sys(fd, buf, len)
    siguiente_token();  // skip leer_sys
    si (tok_type == 4) { siguiente_token(); }  // skip (

    // fd (first arg)
    compile_comparison();
    emit_push();  // save fd on stack
    si (tok_type == 10) { siguiente_token(); }  // skip ,

    // buf (second arg) - should be a variable/array
    compile_comparison();
    emit_push();  // save buf on stack
    si (tok_type == 10) { siguiente_token(); }  // skip ,

    // len (third arg)
    compile_comparison();
    emit_mov_rdx_rax();  // rdx = len

    // Set up rsi (buf)
    emit_pop();
    emit_mov_rsi_rax();

    // Set up rdi (fd)
    emit_pop();
    emit_mov_rdi_rax();

    // syscall number
    emit_mov_rax_imm32(0);  // sys_read
    emit_syscall();

    si (tok_type == 5) { siguiente_token(); }  // skip )
    si (tok_type == 8) { siguiente_token(); }  // skip ;
}

cancion compile_block();

cancion compile_statement() {
    si (tok_type == 1) {
        si (is_kw_salir_sys() == 1) {
            compile_syscall_exit();
            retorno;
        }
        si (is_kw_escribir_sys() == 1) {
            compile_syscall_write();
            retorno;
        }
        si (is_kw_leer_sys() == 1) {
            compile_syscall_read();
            retorno;
        }
        si (is_kw_retorno() == 1) {
            siguiente_token();  // skip retorno
            compile_comparison();
            si (tok_type == 8) { siguiente_token(); }  // skip ;
            emit_leave();
            emit_ret();
            retorno;
        }
        si (is_kw_decreto() == 1) {
            // Variable declaration: decreto name: type = expr;
            // or: decreto name: [size]type = expr;
            siguiente_token();  // skip decreto

            // Now tok_buf has the variable name - add it immediately with default size
            // We'll adjust later if it's an array
            decreto off: entero = sym_add();
            decreto var_size: entero = 8;  // default size
            decreto is_array: entero = 0;
            decreto elem_size: entero = 1;  // 1 for octeto, 8 for entero

            siguiente_token();  // move past name

            si (tok_type == 9) { siguiente_token(); }  // skip :

            // Check for array type: [size]type
            si (tok_type == 19) {
                // '[' - array type
                is_array = 1;
                siguiente_token();  // skip [
                si (tok_type == 2) {
                    var_size = tok_int_val;  // array size
                    siguiente_token();  // skip number
                }
                si (tok_type == 20) { siguiente_token(); }  // skip ]
                // Now get element type
                si (tok_type == 1) {
                    si (is_kw_octeto() == 1) {
                        elem_size = 1;
                    } sino {
                        si (is_kw_entero() == 1) {
                            elem_size = 8;
                        }
                    }
                    siguiente_token();  // skip type
                }
                var_size = var_size * elem_size;
                // Adjust stack offset for array (sym_add only reserved 8 bytes)
                decreto extra: entero = var_size - 8;
                sym_sp = sym_sp - extra;
                off = sym_sp;
                sym_offs[sym_cnt - 1] = off;  // Update the last added symbol's offset
                sym_elem_sizes[sym_cnt - 1] = elem_size;  // Store element size
            } sino {
                // Simple type (scalar - elem_size defaults to 8 for entero)
                sym_elem_sizes[sym_cnt - 1] = 8;
                si (tok_type == 1) { siguiente_token(); }  // skip type
            }

            si (tok_type == 15) {
                // = initializer
                siguiente_token();  // skip =
                compile_comparison();
                emit_store(off);
            } sino {
                si (is_array == 0) {
                    // Initialize to 0 (only for non-arrays)
                    emit_xor_rax_rax();
                    emit_store(off);
                }
            }
            si (tok_type == 8) { siguiente_token(); }  // skip ;
            retorno;
        }
        si (is_kw_si() == 1) {
            // if statement: si (cond) { body } sino { else }
            siguiente_token();  // skip si
            si (tok_type == 4) { siguiente_token(); }  // skip (
            compile_comparison();
            si (tok_type == 5) { siguiente_token(); }  // skip )

            emit_cmp_rax_0();
            decreto je_addr: entero = emit_je();

            si (tok_type == 6) { siguiente_token(); }  // skip {
            mientras (tok_type != 7) {
                compile_statement();
                si (tok_type == 0) { retorno; }
            }
            siguiente_token();  // skip }

            // Check for else
            si (tok_type == 1) {
                si (is_kw_sino() == 1) {
                    decreto jmp_addr: entero = emit_jmp();
                    emit_patch(je_addr);
                    siguiente_token();  // skip sino
                    si (tok_type == 6) { siguiente_token(); }  // skip {
                    mientras (tok_type != 7) {
                        compile_statement();
                        si (tok_type == 0) { retorno; }
                    }
                    siguiente_token();  // skip }
                    emit_patch(jmp_addr);
                    retorno;
                }
            }
            emit_patch(je_addr);
            retorno;
        }
        si (is_kw_mientras() == 1) {
            // while loop: mientras (cond) { body }
            siguiente_token();  // skip mientras
            g_loop_start = code_pos;
            si (tok_type == 4) { siguiente_token(); }  // skip (
            compile_comparison();
            si (tok_type == 5) { siguiente_token(); }  // skip )

            emit_cmp_rax_0();
            g_je_addr = emit_je();

            si (tok_type == 6) { siguiente_token(); }  // skip {
            mientras (tok_type != 7) {
                compile_statement();
                si (tok_type == 0) { retorno; }
            }
            siguiente_token();  // skip }

            // Jump back to loop start
            emit_byte(233);  // jmp rel32
            decreto rel: entero = g_loop_start - code_pos - 4;
            emit_dword(rel);
            emit_patch(g_je_addr);
            retorno;
        }
        // Check for assignment or function call
        g_assign_off = sym_find();
        decreto g_glob_off: entero = 0;
        si (g_assign_off == 0) { g_glob_off = glob_find(); }
        save_call_name();  // Save identifier for potential function call
        siguiente_token();  // consume identifier
        si (tok_type == 15) {
            // Assignment: identifier = expr
            siguiente_token();  // skip =
            compile_comparison();
            si (g_assign_off != 0) {
                emit_store(g_assign_off);
            } sino {
                si (g_glob_off != 0) {
                    emit_store_global(g_glob_off - 1);
                }
            }
            si (tok_type == 8) { siguiente_token(); }  // skip ;
            retorno;
        }
        si (tok_type == 19) {
            // Array element assignment: identifier[index] = expr
            // Get base address of array (local or global) and element size
            si (g_assign_off != 0) {
                emit_lea_rbp_off(g_assign_off);
                g_arr_elem_sz = sym_elem_size();
            } sino {
                si (g_glob_off != 0) {
                    emit_lea_global(g_glob_off - 1);
                    g_arr_elem_sz = glob_elem_size();
                } sino {
                    g_arr_elem_sz = 1;
                }
            }
            emit_push();  // save base address

            siguiente_token();  // skip [

            // Handle index - simplified (number or variable only)
            si (tok_type == 2) {
                emit_mov_rax_imm32(tok_int_val);
                siguiente_token();
            } sino {
                si (tok_type == 1) {
                    decreto idx_off: entero = sym_find();
                    decreto gidx_off: entero = 0;
                    si (idx_off == 0) { gidx_off = glob_find(); }
                    siguiente_token();  // consume identifier before emitting
                    si (idx_off != 0) {
                        emit_load(idx_off);
                    } sino {
                        si (gidx_off != 0) {
                            emit_load_global(gidx_off - 1);
                        } sino {
                            emit_xor_rax_rax();
                        }
                    }
                } sino {
                    emit_xor_rax_rax();
                }
            }

            // Scale index by element size (multiply by 8 for entero arrays)
            si (g_arr_elem_sz == 8) {
                emit_shl_rax_3();
            }

            // Now: rax=scaled_index, stack top=base
            emit_pop_rcx();  // rcx = base address
            emit_add();      // rax = base + scaled_index = final address
            emit_push();     // save destination address

            si (tok_type == 20) { siguiente_token(); }  // skip ]
            si (tok_type == 15) { siguiente_token(); }  // skip =

            // Compile value expression
            compile_comparison();

            // Now: rax=value, stack top=address
            emit_mov_rax_to_rcx();  // rcx = value to store
            emit_pop();             // rax = destination address
            si (g_arr_elem_sz == 8) {
                emit_store_qword_indirect();  // mov [rax], rcx
            } sino {
                emit_store_byte_indirect();  // mov [rax], cl
            }

            si (tok_type == 8) { siguiente_token(); }  // skip ;
            retorno;
        }
        si (tok_type == 4) {
            // Function call as statement: identifier(args);
            decreto fn_addr: entero = fn_find();
            siguiente_token();  // skip (

            // Compile arguments (up to 2 for now)
            si (tok_type != 5) {
                // First argument -> rdi
                compile_comparison();
                emit_mov_rdi_from_rax();

                si (tok_type == 10) {
                    // Second argument -> rsi
                    siguiente_token();  // skip ,
                    compile_comparison();
                    emit_mov_rsi_from_rax();
                }
            }
            si (tok_type == 5) { siguiente_token(); }  // skip )

            // Emit call
            si (fn_addr != 0) {
                emit_call_rel(fn_addr - 1);  // -1 because fn_find returns addr+1
            } sino {
                emit_call();
            }
            si (tok_type == 8) { siguiente_token(); }  // skip ;
            retorno;
        }
        // Unknown identifier statement, skip rest
        si (tok_type == 8) { siguiente_token(); }
        retorno;
    }
    // Skip unknown
    siguiente_token();
}

cancion compile_function() {
    // cancion name(params) { ... }
    sym_reset();  // Reset symbol table for new function
    siguiente_token();  // skip cancion

    // Register function name and address BEFORE emitting prologue
    fn_add();  // Records tok_buf (function name) with current code_pos
    siguiente_token();  // skip name

    si (tok_type == 4) { siguiente_token(); }  // skip (

    // Parse parameters: name: type, name: type, ...
    decreto param_count: entero = 0;
    mientras (tok_type != 5) {
        si (tok_type == 1) {
            // Parameter name - add to symbol table
            sym_add();
            param_count = param_count + 1;
            siguiente_token();  // skip name
            si (tok_type == 9) {
                siguiente_token();  // skip :
                si (tok_type == 1) {
                    siguiente_token();  // skip type
                }
            }
        } sino {
            siguiente_token();  // skip , or other
        }
    }
    si (tok_type == 5) { siguiente_token(); }  // skip )

    // Skip return type if present
    si (tok_type == 9) {
        siguiente_token();  // skip :
        si (tok_type == 1) { siguiente_token(); }  // skip type
    }

    // Check for forward declaration (ends with ; instead of {)
    si (tok_type == 8) {
        siguiente_token();  // skip ;
        retorno;  // Forward declaration - no code to generate
    }

    si (tok_type == 6) { siguiente_token(); }  // skip {

    emit_push_rbp();
    emit_mov_rbp_rsp();
    emit_sub_rsp(256);  // Reserve stack space

    // Copy parameters from registers to stack (System V ABI)
    // rdi=arg1, rsi=arg2, rdx=arg3, rcx=arg4, r8=arg5, r9=arg6
    si (param_count > 0) {
        // mov [rbp-8], rdi
        emit_byte(72);
        emit_byte(137);
        emit_byte(125);
        emit_byte(248);  // -8
    }
    si (param_count > 1) {
        // mov [rbp-16], rsi
        emit_byte(72);
        emit_byte(137);
        emit_byte(117);
        emit_byte(240);  // -16
    }

    mientras (tok_type != 7) {
        compile_statement();
        si (tok_type == 0) { retorno; }
    }
    siguiente_token();  // skip }

    emit_xor_rax_rax();  // Default return 0
    emit_leave();
    emit_ret();
}

// Global variable tracking - sized for self-hosting (compiler has ~60 globals)
decreto glob_names: [4096]octeto;
decreto glob_offs: [128]entero;
decreto glob_sizes: [128]entero;
decreto glob_is_arr: [128]entero;  // 1 if array, 0 if scalar
decreto glob_elem_sizes: [128]entero;  // Element size: 1 for octeto, 8 for entero
decreto glob_cnt: entero = 0;
decreto glob_np: entero = 0;
decreto glob_data_pos: entero = 0;

cancion glob_add(size: entero): entero {
    // Add global variable with given size, return data offset
    decreto i: entero = 0;
    mientras (i < tok_len) {
        glob_names[glob_np] = tok_buf[i];
        glob_np = glob_np + 1;
        i = i + 1;
    }
    glob_names[glob_np] = 0;
    glob_np = glob_np + 1;
    glob_offs[glob_cnt] = glob_data_pos;
    glob_sizes[glob_cnt] = size;
    glob_cnt = glob_cnt + 1;
    glob_data_pos = glob_data_pos + size;
    retorno glob_offs[glob_cnt - 1];
}

cancion compile_global_var() {
    // Global variable declaration: decreto name: [size]type;
    siguiente_token();  // skip decreto

    // tok_buf now has variable name - save name info before moving on
    decreto name_len: entero = tok_len;
    decreto var_size: entero = 8;
    decreto elem_size: entero = 1;
    decreto is_array: entero = 0;

    // Save name to glob_names before siguiente_token overwrites tok_buf
    decreto name_start: entero = glob_np;
    decreto i: entero = 0;
    mientras (i < tok_len) {
        glob_names[glob_np] = tok_buf[i];
        glob_np = glob_np + 1;
        i = i + 1;
    }
    glob_names[glob_np] = 0;
    glob_np = glob_np + 1;

    siguiente_token();  // move past name
    si (tok_type == 9) { siguiente_token(); }  // skip :

    // Check for array type: [size]type
    si (tok_type == 19) {
        is_array = 1;
        siguiente_token();  // skip [
        si (tok_type == 2) {
            var_size = tok_int_val;
            siguiente_token();  // skip number
        }
        si (tok_type == 20) { siguiente_token(); }  // skip ]
        si (tok_type == 1) {
            si (is_kw_octeto() == 1) {
                elem_size = 1;
            } sino {
                si (is_kw_entero() == 1) {
                    elem_size = 8;
                }
            }
            siguiente_token();
        }
        var_size = var_size * elem_size;
    } sino {
        si (tok_type == 1) { siguiente_token(); }
    }

    // Register the global variable
    glob_offs[glob_cnt] = glob_data_pos;
    glob_sizes[glob_cnt] = var_size;
    glob_is_arr[glob_cnt] = is_array;  // Track if it's an array
    glob_elem_sizes[glob_cnt] = elem_size;  // Track element size for arrays
    glob_cnt = glob_cnt + 1;
    glob_data_pos = glob_data_pos + var_size;

    // Skip initializer if present (globals initialize to 0 in BSS)
    si (tok_type == 15) {
        siguiente_token();  // skip =
        si (tok_type == 2) { siguiente_token(); }  // skip number
    }
    si (tok_type == 8) { siguiente_token(); }  // skip ;
}

cancion compile_program() {
    escribir_sys(2, "CP:A\n", 5);
    siguiente_token();
    escribir_sys(2, "CP:B\n", 5);

    // Two-pass compilation to ensure glob_data_pos is complete before code generation

    // First pass: collect all global variable declarations (build glob_data_pos)
    decreto start_pos: entero = pos;
    decreto start_tok: entero = tok_type;
    mientras (tok_type != 0) {
        si (tok_type == 1) {
            si (is_kw_cancion() == 1) {
                // Skip function body - find matching }
                siguiente_token();  // skip cancion
                siguiente_token();  // skip name
                si (tok_type == 4) { siguiente_token(); }  // skip (
                // Skip parameters until )
                mientras (tok_type != 5) {
                    si (tok_type == 0) { retorno; }
                    siguiente_token();
                }
                siguiente_token();  // skip )
                // Skip return type if present
                si (tok_type == 9) {
                    siguiente_token();  // skip :
                    siguiente_token();  // skip type
                }
                // Skip function body { ... }
                si (tok_type == 6) {
                    decreto depth: entero = 1;
                    siguiente_token();  // skip {
                    mientras (depth > 0) {
                        si (tok_type == 0) { retorno; }
                        si (tok_type == 6) { depth = depth + 1; }
                        si (tok_type == 7) { depth = depth - 1; }
                        siguiente_token();
                    }
                }
            } sino {
                si (is_kw_decreto() == 1) {
                    // Process global variable declaration
                    compile_global_var();
                } sino {
                    siguiente_token();
                }
            }
        } sino {
            siguiente_token();
        }
    }

    // Second pass: compile all functions (glob_data_pos is now complete)
    // Reset lexer state for second pass
    pos = 0;
    str_lit_count = 0;
    str_lit_pos = 0;
    siguiente_token();
    mientras (tok_type != 0) {
        si (tok_type == 1) {
            si (is_kw_cancion() == 1) {
                compile_function();
            } sino {
                si (is_kw_decreto() == 1) {
                    // Skip global variable (already processed)
                    siguiente_token();  // skip decreto
                    siguiente_token();  // skip name
                    si (tok_type == 9) { siguiente_token(); }  // skip :
                    // Skip type
                    si (tok_type == 19) {  // [
                        siguiente_token();
                        si (tok_type == 2) { siguiente_token(); }  // skip size
                        si (tok_type == 20) { siguiente_token(); }  // skip ]
                        si (tok_type == 1) { siguiente_token(); }  // skip type
                    } sino {
                        si (tok_type == 1) { siguiente_token(); }  // skip type
                    }
                    // Skip initializer
                    si (tok_type == 15) {
                        siguiente_token();  // skip =
                        si (tok_type == 2) { siguiente_token(); }  // skip value
                    }
                    si (tok_type == 8) { siguiente_token(); }  // skip ;
                } sino {
                    siguiente_token();
                }
            }
        } sino {
            siguiente_token();
        }
    }
    escribir_sys(2, "Pass2 done\n", 11);

    // Resolve any forward references
    escribir_sys(2, "Resolving\n", 10);
    resolve_patches();
    escribir_sys(2, "Resolved\n", 9);

    // Now emit entry stub at end of code - main_addr is already known
    // Save entry stub address for ELF header
    entry_patch_addr = code_pos;  // This is where our entry point will be

    // Calculate relative offset to main_addr from after the call instruction
    // call is at entry_patch_addr, so next instr is at entry_patch_addr + 5
    decreto entry_rel: entero = main_addr - entry_patch_addr - 5;

    // Emit entry stub: call principal, then exit with return value
    emit_byte(232);  // call rel32
    // Emit the relative offset (signed 32-bit)
    si (entry_rel < 0) {
        decreto u: entero = entry_rel + 4294967296;
        emit_byte(u);
        emit_byte(u / 256);
        emit_byte(u / 65536);
        emit_byte(u / 16777216);
    } sino {
        emit_byte(entry_rel);
        emit_byte(entry_rel / 256);
        emit_byte(entry_rel / 65536);
        emit_byte(entry_rel / 16777216);
    }
    emit_byte(72); emit_byte(137); emit_byte(199);  // mov rdi, rax
    emit_byte(72); emit_byte(199); emit_byte(192);  // mov rax, imm32
    emit_byte(60); emit_byte(0); emit_byte(0); emit_byte(0);  // 60 (sys_exit)
    emit_byte(15); emit_byte(5);  // syscall
}

// ============================================================
// ELF GENERATION
// ============================================================

// Streaming output - write directly to stdout for self-hosting support
// This avoids the chicken-and-egg problem where output contains the output buffer
decreto elf_out: [8]octeto;  // Small buffer for streaming output
decreto elf_pos: entero = 0;  // Track position for seeking back if needed

cancion elf_byte(b: entero) {
    elf_out[0] = b;
    escribir_sys(1, elf_out, 1);
    elf_pos = elf_pos + 1;
}

cancion elf_word(w: entero) {
    elf_out[0] = w;
    elf_out[1] = w / 256;
    escribir_sys(1, elf_out, 2);
    elf_pos = elf_pos + 2;
}

cancion elf_dword(d: entero) {
    elf_out[0] = d;
    elf_out[1] = d / 256;
    elf_out[2] = d / 65536;
    elf_out[3] = d / 16777216;
    escribir_sys(1, elf_out, 4);
    elf_pos = elf_pos + 4;
}

cancion elf_qword(q: entero) {
    elf_dword(q);
    elf_dword(0);
}

cancion gen_elf_header() {
    elf_byte(127); elf_byte(69); elf_byte(76); elf_byte(70);
    elf_byte(2); elf_byte(1); elf_byte(1); elf_byte(0);
    elf_byte(0); elf_byte(0); elf_byte(0); elf_byte(0);
    elf_byte(0); elf_byte(0); elf_byte(0); elf_byte(0);
    elf_word(2); elf_word(62); elf_dword(1);
    elf_qword(4198400 + entry_patch_addr);  // Entry point = code base + entry stub offset
    elf_qword(64);
    elf_qword(0);
    elf_dword(0);
    elf_word(64); elf_word(56); elf_word(2);
    elf_word(0); elf_word(0); elf_word(0);
}

cancion gen_program_headers() {
    elf_dword(1); elf_dword(5);
    elf_qword(4096);
    elf_qword(4198400); elf_qword(4198400);
    elf_qword(code_pos); elf_qword(code_pos);
    elf_qword(4096);

    // Data section includes globals + string literals + other data
    decreto total_data: entero = glob_data_pos + str_lit_pos + data_pos;
    elf_dword(1); elf_dword(6);
    elf_qword(69632);
    elf_qword(4263936); elf_qword(4263936);
    elf_qword(total_data); elf_qword(total_data);
    elf_qword(4096);
}

cancion gen_elf() {
    gen_elf_header();
    gen_program_headers();

    mientras (elf_pos < 4096) { elf_byte(0); }

    decreto i: entero = 0;
    mientras (i < code_pos) {
        elf_byte(code[i]);
        i = i + 1;
    }

    mientras (elf_pos < 69632) { elf_byte(0); }

    // Write global variables first (zeroed BSS-style)
    i = 0;
    mientras (i < glob_data_pos) {
        elf_byte(0);
        i = i + 1;
    }

    // Write string literals to data section
    i = 0;
    mientras (i < str_lit_pos) {
        elf_byte(str_lit_data[i]);
        i = i + 1;
    }

    // Also write any other data
    i = 0;
    mientras (i < data_pos) {
        elf_byte(data[i]);
        i = i + 1;
    }
}

// ============================================================
// MAIN
// ============================================================

cancion find_src_len(): entero {
    // Scan backwards from end of buffer to find actual input length
    // This avoids needing leer_sys return value (which crashes in self-hosting)
    decreto i: entero = 131071;
    mientras (i > 0) {
        si (src[i] != 0) {
            retorno i + 1;
        }
        i = i - 1;
    }
    si (src[0] != 0) { retorno 1; }
    retorno 0;
}

cancion principal() {
    escribir_sys(2, "Viva Bootstrap Compiler\n", 24);
    escribir_sys(2, "Reading source from stdin...\n", 29);

    // Read source from stdin
    leer_sys(0, src, 131072);

    // Find actual input length by scanning for last non-null byte
    src_len = find_src_len();
    si (src_len == 0) {
        escribir_sys(2, "Error: no input\n", 16);
        salir_sys(1);
    }

    escribir_sys(2, "Compiling...\n", 13);

    compile_program();

    escribir_sys(2, "Generating ELF...\n", 18);

    gen_elf();

    escribir_sys(2, "Done.\n", 6);

    // Output already written directly to stdout via streaming
    salir_sys(0);
}
